{"/home/travis/build/npmtest/node-npmtest-livescript/test.js":"/* istanbul instrument in package npmtest_livescript */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-livescript/lib.npmtest_livescript.js":"/* istanbul instrument in package npmtest_livescript */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_livescript = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_livescript = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-livescript/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-livescript && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_livescript */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_livescript\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_livescript.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_livescript.rollup.js'] =\n            local.assetsDict['/assets.npmtest_livescript.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_livescript.__dirname + '/lib.npmtest_livescript.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-livescript/node_modules/livescript/lib/index.js":"// Generated by LiveScript 1.5.0\nvar lexer, parser, ast, SourceNode, path, toString$ = {}.toString;\nlexer = require('./lexer');\nparser = require('./parser').parser;\nast = require('./ast');\nSourceNode = require('source-map').SourceNode;\npath = require('path');\nparser.yy = ast;\nparser.lexer = {\n  lex: function(){\n    var ref$, tag, first_line, first_column, last_line, last_column;\n    ref$ = this.tokens[++this.pos] || [''], tag = ref$[0], this.yytext = ref$[1], first_line = ref$[2], first_column = ref$[3];\n    ref$ = this.tokens[this.pos + 1] || [''], last_line = ref$[2], last_column = ref$[3];\n    this.yylineno = first_line;\n    this.yylloc = {\n      first_line: first_line,\n      first_column: first_column,\n      last_line: last_line,\n      last_column: last_column\n    };\n    return tag;\n  },\n  setInput: function(it){\n    this.pos = -1;\n    return this.tokens = it;\n  },\n  upcomingInput: function(){\n    return '';\n  }\n};\nexports.VERSION = '1.5.0';\nexports.compile = function(code, options){\n  var result, ast, output, filename, outputFilename, ref$, mapPath, e, that;\n  options == null && (options = {});\n  options.header == null && (options.header = true);\n  try {\n    if (options.json) {\n      result = Function(exports.compile(code, {\n        bare: true,\n        run: true,\n        print: true\n      }))();\n      return JSON.stringify(result, null, 2) + \"\\n\";\n    } else {\n      ast = parser.parse(lexer.lex(code));\n      if (options.run && options.print) {\n        ast.makeReturn();\n      }\n      output = ast.compileRoot(options);\n      if (options.header) {\n        output = new SourceNode(null, null, null, [\"// Generated by LiveScript \" + exports.VERSION + \"\\n\", output]);\n      }\n      if (options.map && options.map !== 'none') {\n        filename = options.filename, outputFilename = options.outputFilename;\n        if (!filename) {\n          filename = \"unnamed-\" + Math.floor(Math.random() * 4294967296).toString(16) + \".ls\";\n        }\n        output.setFile(filename);\n        result = output.toStringWithSourceMap();\n        if (options.map === 'embedded') {\n          result.map.setSourceContent(filename, code);\n        }\n        if ((ref$ = options.map) === 'linked' || ref$ === 'debug') {\n          mapPath = outputFilename + \".map\";\n          result.code += \"\\n//# sourceMappingURL=\" + mapPath + \"\\n\";\n        } else {\n          result.code += \"\\n//# sourceMappingURL=data:application/json;base64,\" + new Buffer(result.map.toString()).toString('base64') + \"\\n\";\n        }\n        return result;\n      } else {\n        return output.toString();\n      }\n    }\n  } catch (e$) {\n    e = e$;\n    if (that = options.filename) {\n      e.message += \"\\nat \" + that;\n    }\n    throw e;\n  }\n};\nexports.ast = function(it){\n  return parser.parse(typeof it === 'string' ? lexer.lex(it) : it);\n};\nexports.tokens = lexer.lex;\nexports.lex = function(it){\n  return lexer.lex(it, {\n    raw: true\n  });\n};\nexports.run = function(code, options){\n  var output, ref$;\n  output = exports.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$));\n  return Function(toString$.call(output).slice(8, -1) === 'String'\n    ? output\n    : output.code)();\n};\nexports.tokens.rewrite = lexer.rewrite;\nimportAll$(exports.ast, parser.yy);\nif (require.extensions) {\n  require('./node')(exports);\n} else {\n  exports.require = require;\n}\nfunction import$(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n  return obj;\n}\nfunction importAll$(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}","/home/travis/build/npmtest/node-npmtest-livescript/node_modules/livescript/lib/lexer.js":"// Generated by LiveScript 1.5.0\nvar string, TABS, unlines, enlines, enslash, reslash, camelize, deheregex, character, KEYWORDS_SHARED, KEYWORDS_UNUSED, JS_KEYWORDS, LS_KEYWORDS, ID, SYMBOL, SPACE, MULTIDENT, SIMPLESTR, JSTOKEN, BSTOKEN, NUMBER, NUMBER_OMIT, REGEX, HEREGEX_OMIT, LASTDENT, INLINEDENT, NONASCII, OPENERS, CLOSERS, INVERSES, i, o, c, CHAIN, ARG, BLOCK_USERS, this$ = this, slice$ = [].slice;\nexports.lex = function(code, options){\n  return clone$(exports).tokenize(code || '', options || {});\n};\nexports.rewrite = function(it){\n  var ref$;\n  it || (it = this.tokens);\n  firstPass(it);\n  addImplicitIndentation(it);\n  rewriteBlockless(it);\n  addImplicitParentheses(it);\n  addImplicitBraces(it);\n  expandLiterals(it);\n  if (((ref$ = it[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {\n    it.shift();\n  }\n  return it;\n};\nexports.tokenize = function(code, o){\n  var i, prevIndex, c, charsConsumed, that;\n  this.inter || (code = code.replace(/[\\r\\u2028\\u2029\\uFEFF]/g, ''));\n  code = '\\n' + code;\n  this.tokens = [this.last = ['NEWLINE', '\\n', 0, 0]];\n  this.line = ~-o.line;\n  this.column = o.column || 0;\n  this.dents = [];\n  this.closes = [];\n  this.parens = [];\n  this.flags = [];\n  i = 0;\n  prevIndex = i;\n  this.charsCounted = 0;\n  this.isAtPrefix = true;\n  while (c = code.charAt(i)) {\n    charsConsumed = i - prevIndex;\n    prevIndex = i;\n    if (this.charsCounted > charsConsumed) {\n      throw new Error('Location information out-of-sync in lexer');\n    }\n    this.column += charsConsumed - this.charsCounted;\n    this.charsCounted = 0;\n    switch (c) {\n    case ' ':\n      i += this.doSpace(code, i);\n      break;\n    case '\\n':\n      i += this.doLine(code, i);\n      break;\n    case '\\\\':\n      i += this.doBackslash(code, i);\n      break;\n    case '\\'':\n    case '\"':\n      i += this.doString(code, i, c);\n      break;\n    case \"0\":\n    case \"1\":\n    case \"2\":\n    case \"3\":\n    case \"4\":\n    case \"5\":\n    case \"6\":\n    case \"7\":\n    case \"8\":\n    case \"9\":\n      i += this.doNumber(code, i);\n      break;\n    case '/':\n      switch (code.charAt(i + 1)) {\n      case '*':\n        i += this.doComment(code, i);\n        break;\n      case '/':\n        i += this.doHeregex(code, i);\n        break;\n      default:\n        i += this.doRegex(code, i) || this.doLiteral(code, i);\n      }\n      break;\n    case '`':\n      if ('`' === code.charAt(i + 1)) {\n        i += this.doJS(code, i);\n      } else {\n        i += this.doLiteral(code, i);\n      }\n      break;\n    default:\n      i += this.doID(code, i) || this.doLiteral(code, i) || this.doSpace(code, i);\n    }\n  }\n  this.dedent(this.dent);\n  if (that = this.closes.pop()) {\n    this.carp(\"missing `\" + that + \"`\");\n  }\n  if (this.inter) {\n    this.rest == null && this.carp('unterminated interpolation');\n  } else {\n    this.last.spaced = true;\n    this.newline();\n  }\n  o.raw || this.rewrite();\n  return this.tokens;\n};\nexports.dent = 0;\nexports.identifiers = {};\nexports.hasOwn = Object.prototype.hasOwnProperty;\nexports.checkConsistency = function(camel, id){\n  if (this.hasOwn.call(this.identifiers, camel) && this.identifiers[camel] !== id) {\n    throw new ReferenceError(\"Inconsistent use of \" + camel + \" as \" + id + \" on line \" + (-~this.line));\n  } else {\n    return this.identifiers[camel] = id;\n  }\n};\nexports.doID = function(code, index){\n  var regexMatch, input, id, e, last, ref$, tag, ref1$, that;\n  input = (regexMatch = (ID.lastIndex = index, ID).exec(code))[0];\n  if (!input) {\n    return 0;\n  }\n  id = camelize(regexMatch[1]);\n  if (/-/.test(regexMatch[1])) {\n    this.checkConsistency(id, regexMatch[1]);\n  }\n  if (NONASCII.test(id)) {\n    try {\n      Function(\"var \" + id);\n    } catch (e$) {\n      e = e$;\n      this.carp(\"invalid identifier '\" + id + \"'\");\n    }\n  }\n  last = this.last;\n  if (regexMatch[2] || last[0] === 'DOT' || this.adi()) {\n    this.token('ID', in$(id, JS_KEYWORDS) ? (ref$ = Object(id), ref$.reserved = true, ref$) : id);\n    if (regexMatch[2]) {\n      this.token(':', ':');\n    }\n    return input.length;\n  }\n  switch (id) {\n  case 'true':\n  case 'false':\n  case 'on':\n  case 'off':\n  case 'yes':\n  case 'no':\n  case 'null':\n  case 'void':\n  case 'arguments':\n  case 'debugger':\n    tag = 'LITERAL';\n    break;\n  case 'new':\n  case 'do':\n  case 'typeof':\n  case 'delete':\n    tag = 'UNARY';\n    break;\n  case 'yield':\n    tag = 'YIELD';\n    break;\n  case 'return':\n  case 'throw':\n    tag = 'HURL';\n    break;\n  case 'break':\n  case 'continue':\n    tag = 'JUMP';\n    break;\n  case 'this':\n  case 'eval':\n  case 'super':\n    return this.token('LITERAL', id, true).length;\n  case 'for':\n    id = [];\n    this.fset('for', true);\n    this.fset('to', false);\n    this.fset('by', true);\n    break;\n  case 'then':\n    this.fset('for', false);\n    this.fset('to', false);\n    break;\n  case 'catch':\n  case 'function':\n    id = '';\n    break;\n  case 'in':\n  case 'of':\n    if (this.fget('for')) {\n      this.fset('for', false);\n      if (id === 'in') {\n        this.fset('by', true);\n        id = '';\n        if (last[0] === 'ID' && ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) === ',' || ref$ === ']' || ref$ === '}')) {\n          id = this.tokens.pop()[1];\n          if ((ref$ = this.tokens)[ref$.length - 1][0] === ',') {\n            this.tokens.pop();\n          }\n        }\n      }\n      break;\n    }\n    // fallthrough\n  case 'instanceof':\n    if (last[1] === '!') {\n      id = this.tokens.pop()[1] + id;\n    }\n    tag = (ref$ = this.tokens)[ref$.length - 1][0] === '(' ? 'BIOPR' : 'RELATION';\n    break;\n  case 'not':\n    if (last.alias && last[1] === '===') {\n      return last[1] = '!==', 3;\n    }\n    tag = 'UNARY';\n    id = '!';\n    break;\n  case 'and':\n  case 'or':\n  case 'xor':\n  case 'is':\n  case 'isnt':\n    this.unline();\n    tag = id === 'is' || id === 'isnt' ? 'COMPARE' : 'LOGIC';\n    if (last[0] === '(') {\n      tag = 'BIOP';\n    }\n    this.token(tag, (function(){\n      switch (id) {\n      case 'is':\n        return '===';\n      case 'isnt':\n        return '!==';\n      case 'or':\n        return '||';\n      case 'and':\n        return '&&';\n      case 'xor':\n        return 'xor';\n      }\n    }()));\n    this.last.alias = true;\n    return id.length;\n  case 'unless':\n    tag = 'IF';\n    break;\n  case 'until':\n    tag = 'WHILE';\n    break;\n  case 'import':\n    if (last[0] === '(') {\n      id = '<<<';\n      tag = 'BIOP';\n    } else {\n      if (able(this.tokens)) {\n        id = '<<<';\n      } else {\n        tag = 'DECL';\n      }\n    }\n    break;\n  case 'export':\n  case 'const':\n  case 'var':\n    tag = 'DECL';\n    break;\n  case 'with':\n    tag = (function(){\n      switch (false) {\n      case !able(this.tokens):\n        return 'CLONEPORT';\n      case last[0] !== '(':\n        return 'BIOP';\n      default:\n        return 'WITH';\n      }\n    }.call(this));\n    break;\n  case 'when':\n    this.fset('for', false);\n    tag = 'CASE';\n    // fallthrough\n  case 'case':\n    if (this.doCase()) {\n      return input.length;\n    }\n    break;\n  case 'match':\n    tag = 'SWITCH';\n    break;\n  case 'loop':\n    this.token('WHILE', id);\n    this.token('LITERAL', 'true');\n    return input.length;\n  case 'let':\n  case 'own':\n    if (last[0] === 'FOR' && !in$(id, last[1])) {\n      last[1].push(id);\n      return 3;\n    }\n    // fallthrough\n  default:\n    if (in$(id, KEYWORDS_SHARED)) {\n      break;\n    }\n    if (in$(id, KEYWORDS_UNUSED)) {\n      this.carp(\"reserved word '\" + id + \"'\");\n    }\n    if (!last[1] && ((ref$ = last[0]) === 'FUNCTION' || ref$ === 'GENERATOR' || ref$ === 'LABEL')) {\n      last[1] = id;\n      last.spaced = false;\n      return input.length;\n    }\n    tag = 'ID';\n    switch (id) {\n    case 'otherwise':\n      if ((ref$ = last[0]) === 'CASE' || ref$ === '|') {\n        last[0] = 'DEFAULT';\n        return id.length;\n      }\n      break;\n    case 'all':\n      if (that = last[1] === '<<<' && '<' || last[1] === 'import' && 'All') {\n        last[1] += that;\n        return 3;\n      }\n      break;\n    case 'from':\n      if (last[1] === 'yield') {\n        last[1] += 'from';\n        return 4;\n      }\n      this.forange() && (tag = 'FROM');\n      break;\n    case 'to':\n    case 'til':\n      this.forange() && this.tokens.push(['FROM', '', this.line, this.column], ['STRNUM', '0', this.line, this.column]);\n      if (this.fget('from')) {\n        this.fset('from', false);\n        this.fset('by', true);\n        tag = 'TO';\n      } else if (!last.callable && last[0] === 'STRNUM' && (ref$ = this.tokens)[ref$.length - 2][0] === '[') {\n        last[0] = 'RANGE';\n        last.op = id;\n        return id.length;\n      } else if (in$(']', this.closes)) {\n        this.token('TO', id);\n        return id.length;\n      }\n      break;\n    case 'by':\n      if (last[0] === 'STRNUM' && (ref$ = this.tokens)[ref$.length - 2][0] === 'RANGE' && (ref$ = this.tokens)[ref$.length - 3][0] === '[') {\n        tag = 'RANGE_BY';\n      } else if (in$(']', this.closes)) {\n        tag = 'BY';\n      } else if (this.fget('by') && last[0] !== 'FOR') {\n        tag = 'BY';\n        this.fset('by', false);\n      }\n      break;\n    case 'ever':\n      if (last[0] === 'FOR') {\n        this.fset('for', false);\n        last[0] = 'WHILE';\n        tag = 'LITERAL';\n        id = 'true';\n      }\n    }\n  }\n  tag || (tag = regexMatch[1].toUpperCase());\n  if ((tag === 'COMPARE' || tag === 'LOGIC' || tag === 'RELATION') && last[0] === '(') {\n    tag = tag === 'RELATION' ? 'BIOPR' : 'BIOP';\n  }\n  if (tag === 'THEN' || tag === 'IF' || tag === 'WHILE') {\n    this.fset('for', false);\n    this.fset('by', false);\n  }\n  if (tag === 'RELATION' || tag === 'THEN' || tag === 'ELSE' || tag === 'CASE' || tag === 'DEFAULT' || tag === 'CATCH' || tag === 'FINALLY' || tag === 'IN' || tag === 'OF' || tag === 'FROM' || tag === 'TO' || tag === 'BY' || tag === 'EXTENDS' || tag === 'IMPLEMENTS' || tag === 'WHERE') {\n    this.unline();\n  }\n  this.token(tag, id);\n  return input.length;\n};\nexports.doNumber = function(code, lastIndex){\n  var input, regexMatch, last, radix, num, rnum, bound, ref$;\n  NUMBER.lastIndex = lastIndex;\n  if (!(input = (regexMatch = NUMBER.exec(code))[0])) {\n    return 0;\n  }\n  last = this.last;\n  if (regexMatch[5] && (last[0] === 'DOT' || this.adi())) {\n    this.token('STRNUM', regexMatch[4].replace(NUMBER_OMIT, ''));\n    return regexMatch[4].length;\n  }\n  if (radix = regexMatch[1]) {\n    num = parseInt(rnum = regexMatch[2].replace(NUMBER_OMIT, ''), radix);\n    bound = false;\n    if (radix > 36 || radix < 2) {\n      if (/[0-9]/.exec(rnum)) {\n        this.carp(\"invalid number base \" + radix + \" (with number \" + rnum + \"),base must be from 2 to 36\");\n      } else {\n        bound = true;\n      }\n    }\n    if (isNaN(num) || num === parseInt(rnum.slice(0, -1), radix)) {\n      this.strnum(regexMatch[1]);\n      this.token('DOT', '.~');\n      this.token('ID', regexMatch[2]);\n      return input.length;\n    }\n    num += '';\n  } else {\n    num = (regexMatch[3] || input).replace(NUMBER_OMIT, '');\n    if (regexMatch[3] && num.charAt() === '0' && ((ref$ = num.charAt(1)) !== '' && ref$ !== '.')) {\n      this.carp(\"deprecated octal literal \" + regexMatch[4]);\n    }\n  }\n  if (!last.spaced && last[0] === '+-') {\n    last[0] = 'STRNUM';\n    last[1] += num;\n    return input.length;\n  }\n  this.strnum(num);\n  return input.length;\n};\nexports.doString = function(code, index, q){\n  var parts, str;\n  if (q === code.charAt(index + 1)) {\n    return q === code.charAt(index + 2)\n      ? this.doHeredoc(code, index, q)\n      : (this.strnum(q + q), 2);\n  }\n  if (q === '\"') {\n    parts = this.interpolate(code, index, q);\n    this.addInterpolated(parts, unlines);\n    return parts.size;\n  }\n  str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp('unterminated string');\n  this.strnum(unlines(this.string(q, str.slice(1, -1))));\n  return this.countLines(str).length;\n};\nexports.doHeredoc = function(code, index, q){\n  var end, raw, doc, parts, tabs, i$, len$, i, t;\n  if (q === '\\'') {\n    ~(end = code.indexOf(q + q + q, index + 3)) || this.carp('unterminated heredoc');\n    raw = code.slice(index + 3, end);\n    doc = raw.replace(LASTDENT, '');\n    this.strnum(enlines(this.string(q, lchomp(detab(doc, heretabs(doc))))));\n    return this.countLines(raw).length + 6;\n  }\n  parts = this.interpolate(code, index, q + q + q);\n  tabs = heretabs(code.slice(index + 3, index + parts.size - 3).replace(LASTDENT, ''));\n  for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {\n    i = i$;\n    t = parts[i$];\n    if (t[0] === 'S') {\n      if (i + 1 === parts.length) {\n        t[1] = t[1].replace(LASTDENT, '');\n      }\n      t[1] = detab(t[1], tabs);\n      if (i === 0) {\n        t[1] = lchomp(t[1]);\n      }\n    }\n  }\n  this.addInterpolated(parts, enlines);\n  return parts.size;\n};\nexports.doComment = function(code, index){\n  var comment, end, ref$;\n  comment = ~(end = code.indexOf('*/', index + 2))\n    ? code.slice(index, end + 2)\n    : code.slice(index) + '*/';\n  if ((ref$ = this.last[0]) === 'NEWLINE' || ref$ === 'INDENT' || ref$ === 'THEN') {\n    this.token('COMMENT', detab(comment, this.dent));\n    this.token('NEWLINE', '\\n');\n  }\n  return this.countLines(comment).length;\n};\nexports.doJS = function(code, lastIndex){\n  var js, ref$;\n  JSTOKEN.lastIndex = lastIndex;\n  js = JSTOKEN.exec(code)[0] || this.carp('unterminated JS literal');\n  this.token('LITERAL', (ref$ = Object(detab(js.slice(2, -2), this.dent)), ref$.js = true, ref$), true);\n  return this.countLines(js).length;\n};\nexports.doRegex = function(code, index){\n  var divisible, ref$, input, body, flag;\n  if (divisible = able(this.tokens) || this.last[0] === 'CREMENT') {\n    if (!this.last.spaced || ((ref$ = code.charAt(index + 1)) === ' ' || ref$ === '=')) {\n      return 0;\n    }\n  }\n  ref$ = (REGEX.lastIndex = index, REGEX).exec(code), input = ref$[0], body = ref$[1], flag = ref$[2];\n  if (input) {\n    this.regex(body, flag);\n  } else if (!divisible && this.last[0] !== '(') {\n    this.carp('unterminated regex');\n  }\n  return input.length;\n};\nexports.doHeregex = function(code, index){\n  var tokens, last, parts, rest, flag, i$, i, t, dynaflag, len$, val, one;\n  tokens = this.tokens, last = this.last;\n  parts = this.interpolate(code, index, '//');\n  rest = code.slice(index + parts.size);\n  flag = this.validate(/^(?:[gimy]{1,4}|[?$]?)/.exec(rest)[0]);\n  if (parts[1]) {\n    if (flag === '$') {\n      this.adi();\n      this.token('(', '\"');\n    } else {\n      tokens.push(['ID', 'RegExp', last[2], last[3]], ['CALL(', '', last[2], last[3]]);\n      if (flag === '?') {\n        for (i$ = parts.length - 1; i$ >= 0; --i$) {\n          i = i$;\n          t = parts[i$];\n          if (t[0] === 'TOKENS') {\n            dynaflag = parts.splice(i, 1)[0][1];\n            break;\n          }\n        }\n      }\n    }\n    for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {\n      i = i$;\n      t = parts[i$];\n      if (t[0] === 'TOKENS') {\n        tokens.push.apply(tokens, t[1]);\n      } else {\n        val = deheregex(t[1]);\n        if (one && !val) {\n          continue;\n        }\n        one = tokens.push((t[0] = 'STRNUM', t[1] = this.string('\\'', enslash(val)), t));\n      }\n      tokens.push(['+-', '+', tokens[tokens.length - 1][2], tokens[tokens.length - 1][3]]);\n    }\n    --tokens.length;\n    if (dynaflag || flag >= 'g') {\n      this.token(',', ',');\n      if (dynaflag) {\n        tokens.push.apply(tokens, dynaflag);\n      } else {\n        this.token('STRNUM', \"'\" + flag + \"'\");\n      }\n    }\n    this.token(flag === '$' ? ')' : ')CALL', '');\n  } else {\n    this.regex(reslash(deheregex(parts[0][1])), flag);\n  }\n  return parts.size + flag.length;\n};\nexports.doBackslash = function(code, lastIndex){\n  var ref$, input, word;\n  BSTOKEN.lastIndex = lastIndex;\n  ref$ = BSTOKEN.exec(code), input = ref$[0], word = ref$[1];\n  if (word) {\n    this.strnum(this.string('\\'', word));\n  } else {\n    this.countLines(input);\n  }\n  return input.length;\n};\nexports.doLine = function(code, index){\n  var ref$, input, tabs, length, last, that, delta, tag, val;\n  ref$ = (MULTIDENT.lastIndex = index, MULTIDENT).exec(code), input = ref$[0], tabs = ref$[1];\n  length = this.countLines(input).length;\n  last = this.last;\n  last.eol = true;\n  last.spaced = true;\n  if (index + length >= code.length) {\n    return length;\n  }\n  if (that = tabs && (this.emender || (this.emender = RegExp('[^' + tabs.charAt() + ']'))).exec(tabs)) {\n    this.carp(\"contaminated indent \" + escape(that));\n  }\n  if (0 > (delta = tabs.length - this.dent)) {\n    this.dedent(-delta);\n    this.newline();\n  } else {\n    tag = last[0], val = last[1];\n    if (tag === 'ASSIGN' && ((ref$ = val + '') !== '=' && ref$ !== ':=' && ref$ !== '+=') || val === '++' && (ref$ = this.tokens)[ref$.length - 2].spaced || (tag === '+-' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === 'DOT' || tag === 'LOGIC' || tag === 'MATH' || tag === 'COMPARE' || tag === 'RELATION' || tag === 'SHIFT' || tag === 'IN' || tag === 'OF' || tag === 'TO' || tag === 'BY' || tag === 'FROM' || tag === 'EXTENDS' || tag === 'IMPLEMENTS')) {\n      return length;\n    }\n    if (delta) {\n      this.indent(delta);\n    } else {\n      this.newline();\n    }\n  }\n  this.fset('for', false);\n  this.fset('by', false);\n  return length;\n};\nexports.doSpace = function(code, lastIndex){\n  var input;\n  SPACE.lastIndex = lastIndex;\n  if (input = SPACE.exec(code)[0]) {\n    this.last.spaced = true;\n  }\n  return input.length;\n};\nexports.doCase = function(){\n  var ref$, ref1$;\n  this.seenFor = false;\n  if (((ref$ = this.last[0]) === 'ASSIGN' || ref$ === '->' || ref$ === ':') || (this.last[0] === 'INDENT' && ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) === 'ASSIGN' || ref$ === '->' || ref$ === ':'))) {\n    this.token('SWITCH', 'switch');\n    return this.token('CASE', 'case');\n  }\n};\nexports.doLiteral = function(code, index){\n  var sym, tag, val, ref$, that;\n  if (!(sym = (SYMBOL.lastIndex = index, SYMBOL).exec(code)[0])) {\n    return 0;\n  }\n  switch (tag = val = sym) {\n  case '|':\n    tag = 'CASE';\n    if (this.doCase()) {\n      return sym.length;\n    }\n    break;\n  case '|>':\n    tag = 'PIPE';\n    break;\n  case '`':\n    tag = 'BACKTICK';\n    break;\n  case '<<':\n  case '>>':\n    tag = 'COMPOSE';\n    break;\n  case '<|':\n    tag = 'BACKPIPE';\n    break;\n  case '+':\n  case '-':\n    tag = '+-';\n    break;\n  case '&&':\n  case '||':\n    tag = 'LOGIC';\n    break;\n  case '.&.':\n  case '.|.':\n  case '.^.':\n    tag = 'BITWISE';\n    break;\n  case '^^':\n    tag = 'CLONE';\n    break;\n  case '**':\n  case '^':\n    tag = 'POWER';\n    break;\n  case '?':\n    if (this.last[0] === '(') {\n      this.token('PARAM(', '(');\n      this.token(')PARAM', ')');\n      this.token('->', '->');\n      this.token('ID', 'it');\n    } else {\n      if (this.last.spaced) {\n        tag = 'LOGIC';\n      }\n    }\n    break;\n  case '/':\n  case '%':\n  case '%%':\n    tag = 'MATH';\n    break;\n  case '++':\n  case '--':\n    tag = 'CREMENT';\n    break;\n  case '<<<':\n  case '<<<<':\n    tag = 'IMPORT';\n    break;\n  case ';':\n    tag = 'NEWLINE';\n    this.fset('by', false);\n    break;\n  case '..':\n    this.token('LITERAL', '..', true);\n    return 2;\n  case '.':\n    if (this.last[1] === '?') {\n      this.last[0] = '?';\n    }\n    tag = 'DOT';\n    break;\n  case ',':\n    switch (this.last[0]) {\n    case ',':\n    case '[':\n    case '(':\n    case 'CALL(':\n      this.token('LITERAL', 'void');\n      break;\n    case 'FOR':\n    case 'OWN':\n      this.token('ID', '');\n    }\n    break;\n  case '!=':\n  case '~=':\n    if (!(able(this.tokens) || ((ref$ = this.last[0]) === '(' || ref$ === 'CREMENT'))) {\n      this.tokens.push(val === '!='\n        ? ['UNARY', '!', this.line, this.column]\n        : ['UNARY', '~', this.line, this.column], ['ASSIGN', '=', this.line, this.column]);\n      return 2;\n    }\n    // fallthrough\n  case '!~=':\n  case '==':\n    val = (function(){\n      switch (val) {\n      case '~=':\n        return '==';\n      case '!~=':\n        return '!=';\n      case '==':\n        return '===';\n      case '!=':\n        return '!==';\n      }\n    }());\n    tag = 'COMPARE';\n    break;\n  case '===':\n  case '!==':\n    val += '=';\n    // fallthrough\n  case '<':\n  case '>':\n  case '<=':\n  case '>=':\n  case '<==':\n  case '>==':\n  case '>>=':\n  case '<<=':\n    tag = 'COMPARE';\n    break;\n  case '.<<.':\n  case '.>>.':\n  case '.>>>.':\n  case '<?':\n  case '>?':\n    tag = 'SHIFT';\n    break;\n  case '(':\n    if (!(((ref$ = this.last[0]) === 'FUNCTION' || ref$ === 'GENERATOR' || ref$ === 'LET') || this.able(true) || this.last[1] === '.@')) {\n      this.token('(', '(');\n      this.closes.push(')');\n      this.parens.push(this.last);\n      return 1;\n    }\n    tag = 'CALL(';\n    this.closes.push(')CALL');\n    break;\n  case '[':\n  case '{':\n    this.adi();\n    this.closes.push(']}'.charAt(val === '{'));\n    break;\n  case '}':\n    if (this.inter && val !== (ref$ = this.closes)[ref$.length - 1]) {\n      this.rest = code.slice(index + 1);\n      return 9e9;\n    }\n    // fallthrough\n  case ']':\n  case ')':\n    if (tag === ')' && ((ref$ = this.last[0]) === '+-' || ref$ === 'COMPARE' || ref$ === 'LOGIC' || ref$ === 'MATH' || ref$ === 'POWER' || ref$ === 'SHIFT' || ref$ === 'BITWISE' || ref$ === 'CONCAT' || ref$ === 'COMPOSE' || ref$ === 'RELATION' || ref$ === 'PIPE' || ref$ === 'BACKPIPE' || ref$ === 'IMPORT' || ref$ === 'CLONEPORT' || ref$ === 'ASSIGN')) {\n      (ref$ = this.tokens)[ref$.length - 1][0] = (function(){\n        switch (this.last[0]) {\n        case 'RELATION':\n          return 'BIOPR';\n        case 'PIPE':\n          this.parameters(false, -1);\n          return 'BIOPP';\n        default:\n          return 'BIOP';\n        }\n      }.call(this));\n    }\n    if (')' === (tag = val = this.pair(val))) {\n      this.lpar = this.parens.pop();\n    }\n    break;\n  case '=':\n  case ':':\n    if (val === ':') {\n      switch (this.last[0]) {\n      case 'ID':\n      case 'STRNUM':\n      case ')':\n        break;\n      case '...':\n        this.last[0] = 'STRNUM';\n        break;\n      default:\n        tag = 'LABEL';\n        val = '';\n      }\n      this.token(tag, val);\n      return sym.length;\n    }\n    // fallthrough\n  case ':=':\n  case '+=':\n  case '-=':\n  case '*=':\n  case '/=':\n  case '%=':\n  case '%%=':\n  case '<?=':\n  case '>?=':\n  case '**=':\n  case '^=':\n  case '.&.=':\n  case '.|.=':\n  case '.^.=':\n  case '.<<.=':\n  case '.>>.=':\n  case '.>>>.=':\n  case '++=':\n  case '|>=':\n    if (this.last[1] === '.' || this.last[0] === '?' && this.adi()) {\n      this.last[1] += val;\n      return val.length;\n    }\n    if (this.last[0] === 'LOGIC') {\n      (val = Object(val)).logic = this.tokens.pop()[1];\n    } else if ((val === '+=' || val === '-=') && !able(this.tokens) && ((ref$ = this.last[0]) !== '+-' && ref$ !== 'UNARY' && ref$ !== 'LABEL')) {\n      this.token('UNARY', val.charAt());\n      val = '=';\n    }\n    tag = 'ASSIGN';\n    break;\n  case '::=':\n    this.token('DOT', '.');\n    this.token('ID', 'prototype');\n    this.token('IMPORT', '<<');\n    return sym.length;\n  case '*':\n    if (this.last[0] === 'FUNCTION') {\n      this.last[0] = 'GENERATOR';\n      return sym.length;\n    }\n    if (that = ((ref$ = this.last[0]) === 'NEWLINE' || ref$ === 'INDENT' || ref$ === 'THEN' || ref$ === '=>') && (INLINEDENT.lastIndex = index + 1, INLINEDENT).exec(code)[0].length) {\n      this.tokens.push(['LITERAL', 'void', this.line, this.column], ['ASSIGN', '=', this.line, this.column]);\n      this.indent(index + that - 1 - this.dent - code.lastIndexOf('\\n', index - 1));\n      return that;\n    }\n    tag = able(this.tokens) || this.last[0] === 'CREMENT' && able(this.tokens, this.tokens.length - 1) || this.last[0] === '(' ? 'MATH' : 'STRNUM';\n    break;\n  case '@':\n    this.adi();\n    if (this.last[0] === 'DOT' && this.last[1] === '.' && (ref$ = this.tokens)[ref$.length - 2][0] === 'ID' && (ref$ = this.tokens)[ref$.length - 2][1] === 'constructor') {\n      this.tokens.pop();\n      this.tokens.pop();\n      this.token('LITERAL', 'this', true);\n      this.adi();\n      this.token('ID', 'constructor', true);\n    } else {\n      this.token('LITERAL', 'this', true);\n    }\n    return 1;\n  case '@@':\n    this.adi();\n    this.token('ID', 'constructor', true);\n    return 2;\n  case '&':\n    this.token('LITERAL', 'arguments');\n    return 1;\n  case '!':\n    switch (false) {\n    default:\n      if (!this.last.spaced) {\n        if (this.last[1] === 'require') {\n          this.last[0] = 'REQUIRE';\n          this.last[1] = 'require!';\n        } else if (able(this.tokens, null, true)) {\n          this.token('CALL(', '!');\n          this.token(')CALL', ')');\n        } else if (this.last[1] === 'typeof') {\n          this.last[1] = 'classof';\n        } else if (this.last[1] === 'delete') {\n          this.last[1] = 'jsdelete';\n        } else {\n          break;\n        }\n        return 1;\n      }\n    }\n    tag = 'UNARY';\n    break;\n  case '|':\n    tag = 'BITWISE';\n    break;\n  case '~':\n    if (this.dotcat(val)) {\n      return 1;\n    }\n    tag = 'UNARY';\n    break;\n  case '::':\n    this.adi();\n    val = 'prototype';\n    tag = 'ID';\n    break;\n  case '=>':\n    this.unline();\n    this.fset('for', false);\n    tag = 'THEN';\n    break;\n  default:\n    if (/^!?(?:--?|~~?)>\\*?$/.test(val)) {\n      this.parameters(tag = '->');\n    } else if (/^\\*?<(?:--?|~~?)!?$/.test(val)) {\n      this.parameters(tag = '<-');\n    } else {\n      switch (val.charAt(0)) {\n      case '(':\n        this.token('CALL(', '(');\n        tag = ')CALL';\n        val = ')';\n        break;\n      case '<':\n        if (val.length < 4) {\n          this.carp('unterminated words');\n        }\n        this.token('WORDS', val.slice(2, -2), this.adi());\n        return this.countLines(val).length;\n      }\n    }\n  }\n  if ((tag === '+-' || tag === 'COMPARE' || tag === 'LOGIC' || tag === 'MATH' || tag === 'POWER' || tag === 'SHIFT' || tag === 'BITWISE' || tag === 'CONCAT' || tag === 'RELATION' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === 'IMPORT') && this.last[0] === '(') {\n    tag = tag === 'BACKPIPE' ? 'BIOPBP' : 'BIOP';\n  }\n  if (tag === ',' || tag === 'CASE' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === 'DOT' || tag === 'LOGIC' || tag === 'COMPARE' || tag === 'MATH' || tag === 'POWER' || tag === 'IMPORT' || tag === 'SHIFT' || tag === 'BITWISE') {\n    this.unline();\n  }\n  this.token(tag, val);\n  return sym.length;\n};\nexports.token = function(tag, value, callable){\n  this.tokens.push(this.last = [tag, value, this.line, this.column]);\n  if (callable) {\n    this.last.callable = true;\n  }\n  return value;\n};\nexports.indent = function(delta){\n  this.dent += delta;\n  this.dents.push(this.token('INDENT', delta));\n  this.closes.push('DEDENT');\n};\nexports.dedent = function(debt){\n  var dent;\n  this.dent -= debt;\n  while (debt > 0 && (dent = this.dents.pop())) {\n    if (debt < dent && !this.inter) {\n      this.carp(\"unmatched dedent (\" + debt + \" for \" + dent + \")\");\n    }\n    this.pair('DEDENT');\n    debt -= typeof dent === 'number' ? this.token('DEDENT', dent) : dent;\n  }\n};\nexports.newline = function(){\n  var ref$;\n  this.last[1] === '\\n' || this.tokens.push(this.last = (ref$ = ['NEWLINE', '\\n', this.line, this.column], ref$.spaced = true, ref$));\n};\nexports.unline = function(){\n  var ref$;\n  if (!this.tokens[1]) {\n    return;\n  }\n  switch (this.last[0]) {\n  case 'INDENT':\n    (ref$ = this.dents)[ref$.length - 1] += '';\n    // fallthrough\n  case 'NEWLINE':\n    this.tokens.length--;\n  }\n};\nexports.parameters = function(arrow, offset){\n  var i$, ref$, i, t, ref1$;\n  if (this.last[0] === ')' && ')' === this.last[1]) {\n    this.lpar[0] = 'PARAM(';\n    this.last[0] = ')PARAM';\n    return;\n  }\n  if (arrow === '->') {\n    this.token('PARAM(', '');\n  } else {\n    for (i$ = (ref$ = this.tokens).length - 1; i$ >= 0; --i$) {\n      i = i$;\n      t = ref$[i$];\n      if ((ref1$ = t[0]) === 'NEWLINE' || ref1$ === 'INDENT' || ref1$ === 'THEN' || ref1$ === '=>' || ref1$ === '(') {\n        break;\n      }\n    }\n    this.tokens.splice(i + 1, 0, ['PARAM(', '', t[2], t[3]]);\n  }\n  if (offset) {\n    this.tokens.splice(this.tokens.length + offset, 0, [')PARAM', '', t[2], t[3]]);\n  } else {\n    this.token(')PARAM', '');\n  }\n};\nexports.interpolate = function(str, idx, end){\n  var parts, end0, pos, i, ref$, oldLine, oldColumn, ch, c1, id, stringified, length, tag, e, delta, nested, clone, ref1$;\n  parts = [];\n  end0 = end.charAt(0);\n  pos = 0;\n  i = -1;\n  str = str.slice(idx + end.length);\n  ref$ = [this.line, this.column], oldLine = ref$[0], oldColumn = ref$[1];\n  this.countLines(end);\n  while (ch = str.charAt(++i)) {\n    switch (ch) {\n    case end0:\n      if (end !== str.slice(i, i + end.length)) {\n        continue;\n      }\n      parts.push(['S', this.countLines(str.slice(0, i)), oldLine, oldColumn]);\n      this.countLines(end);\n      return parts.size = pos + i + end.length * 2, parts;\n    case '#':\n      c1 = str.charAt(i + 1);\n      id = in$(c1, ['@']) && c1 || (ID.lastIndex = i + 1, ID).exec(str)[1];\n      if (!(id || c1 === '{')) {\n        continue;\n      }\n      break;\n    case '\\\\':\n      ++i;\n      // fallthrough\n    default:\n      continue;\n    }\n    if (i || nested && !stringified) {\n      stringified = parts.push(['S', this.countLines(str.slice(0, i)), oldLine, oldColumn]);\n      ref$ = [this.line, this.column], oldLine = ref$[0], oldColumn = ref$[1];\n    }\n    if (id) {\n      length = id.length;\n      if (id === '@') {\n        id = 'this';\n      }\n      if (in$(id, ['this'])) {\n        tag = 'LITERAL';\n      } else {\n        id = camelize(id);\n        try {\n          Function(\"'use strict'; var \" + id);\n        } catch (e$) {\n          e = e$;\n          this.carp(\"invalid variable interpolation '\" + id + \"'\");\n        }\n        tag = 'ID';\n      }\n      str = str.slice(delta = i + 1 + length);\n      parts.push(['TOKENS', nested = [[tag, id, this.line, this.column]]]);\n    } else {\n      clone = (ref$ = clone$(exports), ref$.inter = true, ref$.emender = this.emender, ref$);\n      nested = clone.tokenize(str.slice(i + 2), {\n        line: this.line,\n        column: this.column + 2,\n        raw: true\n      });\n      delta = str.length - clone.rest.length;\n      this.countLines(str.slice(i, delta));\n      str = clone.rest;\n      while (((ref$ = nested[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {\n        nested.shift();\n      }\n      if (nested.length) {\n        nested.unshift(['(', '(', oldLine, oldColumn]);\n        nested.push([')', ')', this.line, this.column - 1]);\n        parts.push(['TOKENS', nested]);\n      }\n      ref1$ = [this.line, this.column], oldLine = ref1$[0], oldColumn = ref1$[1];\n    }\n    pos += delta;\n    i = -1;\n  }\n  this.carp(\"missing `\" + end + \"`\");\n};\nexports.addInterpolated = function(parts, nlines){\n  var tokens, last, ref$, left, right, joint, callable, i$, len$, i, t;\n  if (!parts[1]) {\n    return this.strnum(nlines(this.string('\"', parts[0][1])));\n  }\n  tokens = this.tokens, last = this.last;\n  ref$ = !last.spaced && last[1] === '%'\n    ? (--tokens.length, this.last = last = tokens[tokens.length - 1], ['[', ']', [',', ',']])\n    : ['(', ')', ['+-', '+']], left = ref$[0], right = ref$[1], joint = ref$[2];\n  callable = this.adi();\n  tokens.push([left, '\"', last[2], last[3]]);\n  for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {\n    i = i$;\n    t = parts[i$];\n    if (t[0] === 'TOKENS') {\n      tokens.push.apply(tokens, t[1]);\n    } else {\n      if (i > 1 && !t[1]) {\n        continue;\n      }\n      tokens.push(['STRNUM', nlines(this.string('\"', t[1])), t[2], t[3]]);\n    }\n    tokens.push(joint.concat(tokens[tokens.length - 1][2], tokens[tokens.length - 1][3]));\n  }\n  --tokens.length;\n  this.token(right, '', callable);\n};\nexports.strnum = function(it){\n  this.token('STRNUM', it, this.adi() || this.last[0] === 'DOT');\n};\nexports.regex = function(body, flag){\n  var e;\n  try {\n    RegExp(body);\n  } catch (e$) {\n    e = e$;\n    this.carp(e.message);\n  }\n  if (flag === '$') {\n    return this.strnum(this.string('\\'', enslash(body)));\n  }\n  return this.token('LITERAL', \"/\" + (body || '(?:)') + \"/\" + this.validate(flag));\n};\nexports.adi = function(){\n  if (this.last.spaced) {\n    return;\n  }\n  if (!able(this.tokens)) {\n    return;\n  }\n  return this.token('DOT', '.');\n};\nexports.dotcat = function(it){\n  if (this.last[1] === '.' || this.adi()) {\n    return this.last[1] += it;\n  }\n};\nexports.pair = function(it){\n  var wanted, ref$;\n  if (!(it === (wanted = (ref$ = this.closes)[ref$.length - 1]) || ')CALL' === wanted && it === ')')) {\n    if ('DEDENT' !== wanted) {\n      this.carp(\"unmatched `\" + it + \"`\");\n    }\n    this.dedent((ref$ = this.dents)[ref$.length - 1]);\n    return this.pair(it);\n  }\n  this.unline();\n  return this.closes.pop();\n};\nexports.able = function(call){\n  return !this.last.spaced && able(this.tokens, null, call);\n};\nexports.countLines = function(it){\n  var pos;\n  if (!this.isAtPrefix) {\n    this.column += it.length;\n  }\n  while (pos = 1 + it.indexOf('\\n', pos)) {\n    if (!this.isAtPrefix) {\n      this.column = 0;\n    }\n    this.column += it.length - pos;\n    ++this.line;\n    this.isAtPrefix = false;\n  }\n  this.charsCounted += it.length;\n  return it;\n};\nexports.forange = function(){\n  var ref$, ref1$, ref2$;\n  if (((ref$ = (ref1$ = this.tokens)[ref1$.length - 2 - ((ref2$ = this.last[0]) === 'NEWLINE' || ref2$ === 'INDENT')]) != null ? ref$[0] : void 8) === 'FOR' || this.last[0] === 'FOR') {\n    this.fset('for', false);\n    this.fset('from', true);\n    return true;\n  } else {\n    return false;\n  }\n};\nexports.validate = function(flag){\n  var that;\n  if (that = flag && /(.).*\\1/.exec(flag)) {\n    this.carp(\"duplicate regex flag `\" + that[1] + \"`\");\n  }\n  return flag;\n};\nexports.fget = function(key){\n  var ref$;\n  return (ref$ = this.flags[this.closes.length]) != null ? ref$[key] : void 8;\n};\nexports.fset = function(key, val){\n  var ref$, key$;\n  ((ref$ = this.flags)[key$ = this.closes.length] || (ref$[key$] = {}))[key] = val;\n};\nexports.carp = function(it){\n  carp(it, this.line);\n};\nexports.string = function(q, body){\n  return string(q, body, this.line);\n};\nfunction carp(msg, lno){\n  throw SyntaxError(msg + \" on line \" + (-~lno));\n}\nfunction able(tokens, i, call){\n  var token, tag;\n  i == null && (i = tokens.length);\n  tag = (token = tokens[i - 1])[0];\n  return (tag === 'ID' || tag === ']' || tag === '?') || (call\n    ? token.callable || (tag === ')' || tag === ')CALL' || tag === 'BIOPBP') && token[1]\n    : tag === '}' || tag === ')' || tag === ')CALL' || tag === 'STRNUM' || tag === 'LITERAL' || tag === 'WORDS');\n}\nstring = (function(re){\n  return function(q, body, lno){\n    body = body.replace(re, function(it, oct, xu, rest){\n      if (it === q || it === '\\\\') {\n        return '\\\\' + it;\n      }\n      if (oct) {\n        return '\\\\x' + (0x100 + parseInt(oct, 8)).toString(16).slice(1);\n      }\n      if (xu) {\n        carp('malformed character escape sequence', lno);\n      }\n      if (!rest || q === rest) {\n        return it;\n      } else {\n        return rest;\n      }\n    });\n    return q + body + q;\n  };\n}.call(this, /['\"]|\\\\(?:([0-3]?[0-7]{2}|[1-7]|0(?=[89]))|x[\\dA-Fa-f]{2}|u[\\dA-Fa-f]{4}|([xu])|[\\\\0bfnrtv]|[^\\n\\S]|([\\w\\W]))?/g));\nfunction heretabs(doc){\n  var dent, that, ref$;\n  dent = 0 / 0;\n  while (that = TABS.exec(doc)) {\n    dent <= (ref$ = that[0].length - 1) || (dent = ref$);\n  }\n  return dent;\n}\nTABS = /\\n(?!$)[^\\n\\S]*/mg;\nfunction detab(str, len){\n  if (len) {\n    return str.replace(detab[len] || (detab[len] = RegExp('\\\\n[^\\\\n\\\\S]{1,' + len + '}', 'g')), '\\n');\n  } else {\n    return str;\n  }\n}\nunlines = function(it){\n  return it.replace(/\\n[^\\n\\S]*/g, '');\n};\nenlines = function(it){\n  return it.replace(/\\n/g, '\\\\n');\n};\nenslash = function(it){\n  return it.replace(/\\\\/g, '\\\\\\\\');\n};\nreslash = function(it){\n  return it.replace(/(\\\\.)|\\//g, function(){\n    return arguments[1] || '\\\\/';\n  });\n};\ncamelize = function(it){\n  return it.replace(/-[a-z]/ig, function(it){\n    return it.charAt(1).toUpperCase();\n  });\n};\ndeheregex = function(it){\n  return it.replace(/\\s+(?:#.*)?|(\\\\[\\s\\S])/g, function(arg$, bs){\n    bs || (bs = '');\n    if ('\\n' === bs.charAt(1)) {\n      return '\\\\n';\n    } else {\n      return bs;\n    }\n  });\n};\nfunction lchomp(it){\n  return it.slice(1 + it.lastIndexOf('\\n', 0));\n}\nfunction decode(val, lno){\n  if (!isNaN(val)) {\n    return [+val];\n  }\n  val = val.length > 8\n    ? 'ng'\n    : Function('return ' + val)();\n  val.length === 1 || carp('bad string in range', lno);\n  return [val.charCodeAt(), true];\n}\nfunction uxxxx(it){\n  return '\"\\\\u' + ('000' + it.toString(16)).slice(-4) + '\"';\n}\ncharacter = typeof JSON == 'undefined' || JSON === null\n  ? uxxxx\n  : function(it){\n    switch (it) {\n    case 0x2028:\n    case 0x2029:\n      return uxxxx(it);\n    default:\n      return JSON.stringify(String.fromCharCode(it));\n    }\n  };\nfunction firstPass(tokens){\n  var prev, i, token, tag, val, line, column, next, ts, parens, i$, j;\n  prev = ['NEWLINE', '\\n', 0];\n  i = 0;\n  while (token = tokens[++i]) {\n    tag = token[0], val = token[1], line = token[2], column = token[3];\n    switch (false) {\n    case !(tag === 'ASSIGN' && in$(prev[1], LS_KEYWORDS) && tokens[i - 2][0] !== 'DOT'):\n      carp(\"cannot assign to reserved word '\" + prev[1] + \"'\", line);\n      break;\n    case !(tag === 'DOT' && prev[0] === ']' && tokens[i - 2][0] === '[' && tokens[i - 3][0] === 'DOT'):\n      tokens.splice(i - 2, 3);\n      tokens[i - 3][1] = '[]';\n      break;\n    case !(tag === 'DOT' && prev[0] === '}' && tokens[i - 2][0] === '{' && tokens[i - 3][0] === 'DOT'):\n      tokens.splice(i - 2, 3);\n      tokens[i - 3][1] = '{}';\n      break;\n    case !(val === '.' && token.spaced && prev.spaced):\n      tokens[i] = ['COMPOSE', '<<', line, column];\n      break;\n    case val !== '++':\n      if (!(next = tokens[i + 1])) {\n        break;\n      }\n      ts = ['ID', 'LITERAL', 'STRNUM'];\n      if (prev.spaced && token.spaced || !(prev.spaced || token.spaced) && in$(prev[0], ts) && in$(next[0], ts)) {\n        tokens[i][0] = 'CONCAT';\n      }\n      if (prev[0] === '(' && next[0] === ')' || prev[0] === '(' && token.spaced || next[0] === ')' && prev.spaced) {\n        tokens[i][0] = 'BIOP';\n      }\n      break;\n    case tag !== 'DOT':\n      next = tokens[i + 1];\n      if (prev[0] === '(' && next[0] === ')') {\n        tokens[i][0] = 'BIOP';\n      } else if (prev[0] === '(') {\n        tokens.splice(i, 0, ['PARAM(', '(', line, column], [')PARAM', ')', line, column], ['->', '~>', line, column], ['ID', 'it', line, column]);\n      } else if (next[0] === ')') {\n        tokens.splice(i + 1, 0, ['[', '[', line, column], ['ID', 'it', line, column], [']', ']', line, column]);\n        parens = 1;\n        LOOP: for (i$ = i + 1; i$ >= 0; --i$) {\n          j = i$;\n          switch (tokens[j][0]) {\n          case ')':\n            ++parens;\n            break;\n          case '(':\n            if (--parens === 0) {\n              tokens.splice(j + 1, 0, ['PARAM(', '(', line, column], ['ID', 'it', line, column], [')PARAM', ')', line, column], ['->', '~>', line, column]);\n              break LOOP;\n            }\n          }\n        }\n      }\n    }\n    prev = token;\n    continue;\n  }\n}\nfunction rewriteBlockless(tokens){\n  var i, token, tag;\n  i = -1;\n  while (token = tokens[++i]) {\n    tag = token[0];\n    if (tag === 'IF' || tag === 'CLASS' || tag === 'CATCH') {\n      detectEnd(tokens, i + 1, ok, go);\n    }\n  }\n  function ok(it){\n    var ref$;\n    return (ref$ = it[0]) === 'NEWLINE' || ref$ === 'INDENT';\n  }\n  function go(it, i){\n    var lno, cno;\n    if (tag === 'IF') {\n      if (it[0] !== 'INDENT' || !it[1] && !it.then || in$(tokens[i - 1][0], BLOCK_USERS)) {\n        token[0] = 'POST_IF';\n      }\n    } else if (it[0] !== 'INDENT') {\n      tokens.splice(i, 0, ['INDENT', 0, lno = tokens[i - 1][2], cno = tokens[i - 1][3]], ['DEDENT', 0, lno, cno]);\n    }\n  }\n}\nfunction addImplicitIndentation(tokens){\n  var i, token, tag, next, indent, dedent, ref$, ref1$, idx;\n  i = 0;\n  while (token = tokens[++i]) {\n    tag = token[0];\n    if (tag !== '->' && tag !== 'THEN' && tag !== 'ELSE' && tag !== 'DEFAULT' && tag !== 'TRY' && tag !== 'FINALLY' && tag !== 'DECL') {\n      continue;\n    }\n    switch (next = tokens[i + 1][0]) {\n    case 'IF':\n      if (tag === 'ELSE') {\n        continue;\n      }\n      break;\n    case 'INDENT':\n    case 'THEN':\n      if (tag === 'THEN') {\n        tokens.splice(i--, 1);\n      }\n      continue;\n    }\n    indent = ['INDENT', 0, token[2], token[3]];\n    dedent = ['DEDENT', 0];\n    if (tag === 'THEN') {\n      (tokens[i] = indent).then = true;\n    } else {\n      tokens.splice(++i, 0, indent);\n    }\n    switch (false) {\n    case tag !== 'DECL':\n      break;\n    case next !== 'DOT' && next !== '?' && next !== ',' && next !== 'PIPE' && next !== 'BACKPIPE':\n      --i;\n      // fallthrough\n    case !((next === 'ID' || next === 'STRNUM' || next === 'LITERAL') && ',' === ((ref$ = tokens[i + 2]) != null ? ref$[0] : void 8)):\n      go(0, i += 2);\n      ++i;\n      continue;\n    case !((next === '(' || next === '[' || next === '{') && ',' === ((ref1$ = tokens[idx = 1 + indexOfPair(tokens, i + 1)]) != null ? ref1$[0] : void 8)):\n      go(0, idx);\n      ++i;\n      continue;\n    }\n    detectEnd(tokens, i + 1, ok, go);\n  }\n  function ok(token, i){\n    var t0, t;\n    t0 = token[0];\n    t = tag;\n    if (tag === t0 || tag === 'THEN' && t0 === 'SWITCH') {\n      tag = '';\n    }\n    switch (t0) {\n    case 'NEWLINE':\n      return token[1] !== ';';\n    case 'DOT':\n    case '?':\n    case ',':\n    case 'PIPE':\n    case 'BACKPIPE':\n      return tokens[i - 1].eol;\n    case 'ELSE':\n      return t === 'THEN';\n    case 'CATCH':\n      return t === 'TRY';\n    case 'FINALLY':\n      return t === 'TRY' || t === 'CATCH' || t === 'THEN';\n    case 'CASE':\n    case 'DEFAULT':\n      return t === 'CASE' || t === 'THEN';\n    }\n  }\n  function go(arg$, i){\n    var prev;\n    prev = tokens[i - 1];\n    tokens.splice(prev[0] === ',' ? i - 1 : i, 0, (dedent[2] = prev[2], dedent[3] = prev[3], dedent));\n  }\n}\nfunction addImplicitParentheses(tokens){\n  var i, brackets, token, endi, ref$, tpair, tag, prev, ref1$, skipBlock, seenSwitch;\n  i = 0;\n  brackets = [];\n  while (token = tokens[++i]) {\n    if (token[1] === 'do' && tokens[i + 1][0] === 'INDENT') {\n      endi = indexOfPair(tokens, i + 1);\n      if (tokens[endi + 1][0] === 'NEWLINE' && ((ref$ = tokens[endi + 2]) != null ? ref$[0] : void 8) === 'WHILE') {\n        token[0] = 'DO';\n        tokens[endi + 2].done = true;\n        tokens.splice(endi + 1, 1);\n      } else {\n        (token = tokens[1 + i])[0] = '(';\n        (tpair = tokens[endi])[0] = ')';\n        token.doblock = true;\n        tokens.splice(i, 1);\n      }\n    }\n    tag = token[0];\n    prev = tokens[i - 1];\n    tag === '[' && brackets.push(prev[0] === 'DOT');\n    if (prev[0] === ']') {\n      if (brackets.pop()) {\n        prev.index = true;\n      } else {\n        continue;\n      }\n    }\n    if (!(((ref1$ = prev[0]) === 'FUNCTION' || ref1$ === 'GENERATOR' || ref1$ === 'LET' || ref1$ === 'WHERE') || prev.spaced && able(tokens, i, true))) {\n      continue;\n    }\n    if (token.doblock) {\n      token[0] = 'CALL(';\n      tpair[0] = ')CALL';\n      continue;\n    }\n    if (!exp(token)) {\n      continue;\n    }\n    if (tag === 'CREMENT') {\n      if (token.spaced || !in$((ref1$ = tokens[i + 1]) != null ? ref1$[0] : void 8, CHAIN)) {\n        continue;\n      }\n    }\n    skipBlock = seenSwitch = false;\n    tokens.splice(i++, 0, ['CALL(', '', token[2], token[3]]);\n    detectEnd(tokens, i, ok, go);\n  }\n  function exp(token){\n    var tag;\n    tag = token[0];\n    return in$(tag, ARG) || !token.spaced && (tag === '+-' || tag === 'CLONE');\n  }\n  function ok(token, i){\n    var tag, ref$, pre;\n    tag = token[0];\n    if (tag === 'POST_IF' || tag === 'PIPE' || tag === 'BACKPIPE') {\n      return true;\n    }\n    if (!skipBlock) {\n      if (token.alias && ((ref$ = token[1]) === '&&' || ref$ === '||' || ref$ === 'xor') || (tag === 'TO' || tag === 'BY' || tag === 'IMPLEMENTS')) {\n        return true;\n      }\n    }\n    pre = tokens[i - 1];\n    switch (tag) {\n    case 'NEWLINE':\n      return pre[0] !== ',';\n    case 'DOT':\n    case '?':\n      return !skipBlock && (pre.spaced || pre[0] === 'DEDENT');\n    case 'SWITCH':\n      seenSwitch = true;\n      // fallthrough\n    case 'IF':\n    case 'CLASS':\n    case 'FUNCTION':\n    case 'GENERATOR':\n    case 'LET':\n    case 'WITH':\n    case 'CATCH':\n      skipBlock = true;\n      break;\n    case 'CASE':\n      if (seenSwitch) {\n        skipBlock = true;\n      } else {\n        return true;\n      }\n      break;\n    case 'INDENT':\n      if (skipBlock) {\n        return skipBlock = false;\n      }\n      return !in$(pre[0], BLOCK_USERS);\n    case 'WHILE':\n      if (token.done) {\n        return false;\n      }\n      // fallthrough\n    case 'FOR':\n      skipBlock = true;\n      return able(tokens, i) || pre[0] === 'CREMENT' || pre[0] === '...' && pre.spaced;\n    }\n    return false;\n  }\n  function go(token, i){\n    tokens.splice(i, 0, [')CALL', '', tokens[i - 1][2], tokens[i - 1][3]]);\n  }\n}\nfunction addImplicitBraces(tokens){\n  var stack, i, token, tag, start, paren, index, pre, ref$, inline, ref1$;\n  stack = [];\n  i = 0;\n  while (token = tokens[++i]) {\n    if (':' !== (tag = token[0])) {\n      switch (false) {\n      case !in$(tag, CLOSERS):\n        start = stack.pop();\n        break;\n      case !in$(tag, OPENERS):\n        if (tag === 'INDENT' && tokens[i - 1][0] === '{') {\n          tag = '{';\n        }\n        stack.push([tag, i]);\n      }\n      continue;\n    }\n    paren = tokens[i - 1][0] === ')';\n    index = paren\n      ? start[1]\n      : i - 1;\n    pre = tokens[index - 1];\n    if (!(((ref$ = pre[0]) === ':' || ref$ === 'ASSIGN' || ref$ === 'IMPORT') || ((ref$ = stack[stack.length - 1]) != null ? ref$[0] : void 8) !== '{')) {\n      continue;\n    }\n    stack.push(['{']);\n    inline = !pre.doblock && ((ref1$ = pre[0]) !== 'NEWLINE' && ref1$ !== 'INDENT');\n    while (((ref1$ = tokens[index - 2]) != null ? ref1$[0] : void 8) === 'COMMENT') {\n      index -= 2;\n    }\n    tokens.splice(index, 0, ['{', '{', tokens[index][2], tokens[index][3]]);\n    detectEnd(tokens, ++i + 1, ok, go);\n  }\n  function ok(token, i){\n    var tag, t1, ref$, ref1$;\n    switch (tag = token[0]) {\n    case ',':\n      break;\n    case 'NEWLINE':\n      if (inline) {\n        return true;\n      }\n      break;\n    case 'DEDENT':\n      return true;\n    case 'POST_IF':\n    case 'FOR':\n    case 'WHILE':\n      return inline;\n    default:\n      return false;\n    }\n    t1 = (ref$ = tokens[i + 1]) != null ? ref$[0] : void 8;\n    return t1 !== (tag === ',' ? 'NEWLINE' : 'COMMENT') && ':' !== ((ref1$ = tokens[t1 === '('\n      ? 1 + indexOfPair(tokens, i + 1)\n      : i + 2]) != null ? ref1$[0] : void 8);\n  }\n  function go(token, i){\n    tokens.splice(i, 0, ['}', '', token[2], token[3]]);\n  }\n}\nfunction expandLiterals(tokens){\n  var i, fromNum, token, sig, ref$, ref1$, lno, cno, ref2$, ref3$, ref4$, char, toNum, tochar, byNum, byp, ref5$, ts, enc, add, i$, n, ref6$, ref7$, len$, word, that;\n  i = 0;\n  while (token = tokens[++i]) {\n    switch (token[0]) {\n    case 'STRNUM':\n      if (~'-+'.indexOf(sig = token[1].charAt(0))) {\n        token[1] = token[1].slice(1);\n        tokens.splice(i++, 0, ['+-', sig, token[2], token[3]]);\n      }\n      if (token.callable) {\n        continue;\n      }\n      break;\n    case 'TO':\n    case 'TIL':\n      if (!(tokens[i - 1][0] === '[' && ((tokens[i + 2][0] === ']' && (((ref$ = tokens[i + 1][1].charAt(0)) === '\\'' || ref$ === '\"') || +tokens[i + 1][1] >= 0)) || (tokens[i + 2][0] === 'BY' && ((ref$ = tokens[i + 3]) != null ? ref$[0] : void 8) === 'STRNUM' && ((ref1$ = tokens[i + 4]) != null ? ref1$[0] : void 8) === ']')))) {\n        continue;\n      }\n      if (tokens[i + 2][0] === 'BY') {\n        tokens[i + 2][0] = 'RANGE_BY';\n      }\n      token.op = token[1];\n      fromNum = 0;\n      // fallthrough\n    case 'RANGE':\n      lno = token[2];\n      cno = token[3];\n      if (fromNum != null || (tokens[i - 1][0] === '[' && tokens[i + 1][0] === 'STRNUM' && ((tokens[i + 2][0] === ']' && (((ref2$ = tokens[i + 1][1].charAt(0)) === '\\'' || ref2$ === '\"') || +tokens[i + 1][1] >= 0)) || (tokens[i + 2][0] === 'RANGE_BY' && ((ref2$ = tokens[i + 3]) != null ? ref2$[0] : void 8) === 'STRNUM' && ((ref3$ = tokens[i + 4]) != null ? ref3$[0] : void 8) === ']')))) {\n        if (fromNum == null) {\n          ref4$ = decode(token[1], lno), fromNum = ref4$[0], char = ref4$[1];\n        }\n        ref4$ = decode(tokens[i + 1][1], lno), toNum = ref4$[0], tochar = ref4$[1];\n        if (toNum == null || char ^ tochar) {\n          carp('bad \"to\" in range', lno);\n        }\n        byNum = 1;\n        if (byp = ((ref4$ = tokens[i + 2]) != null ? ref4$[0] : void 8) === 'RANGE_BY') {\n          if (!(byNum = +((ref5$ = tokens[i + 3]) != null ? ref5$[1] : void 8))) {\n            carp('bad \"by\" in range', tokens[i + 2][2]);\n          }\n        } else if (fromNum > toNum) {\n          byNum = -1;\n        }\n        ts = [];\n        enc = char ? character : String;\n        add = fn$;\n        if (token.op === 'to') {\n          for (i$ = fromNum; byNum < 0 ? i$ >= toNum : i$ <= toNum; i$ += byNum) {\n            n = i$;\n            add();\n          }\n        } else {\n          for (i$ = fromNum; byNum < 0 ? i$ > toNum : i$ < toNum; i$ += byNum) {\n            n = i$;\n            add();\n          }\n        }\n        ts.pop() || carp('empty range', lno);\n        tokens.splice.apply(tokens, [i, 2 + 2 * byp].concat(slice$.call(ts)));\n        i += ts.length - 1;\n      } else {\n        token[0] = 'STRNUM';\n        if (((ref6$ = tokens[i + 2]) != null ? ref6$[0] : void 8) === 'RANGE_BY') {\n          tokens.splice(i + 2, 1, ['BY', 'by', lno, cno]);\n        }\n        tokens.splice(i + 1, 0, ['TO', token.op, lno, cno]);\n      }\n      fromNum = null;\n      break;\n    case 'WORDS':\n      ts = [['[', '[', lno = token[2], cno = token[3]]];\n      for (i$ = 0, len$ = (ref7$ = token[1].match(/\\S+/g) || '').length; i$ < len$; ++i$) {\n        word = ref7$[i$];\n        ts.push(['STRNUM', string('\\'', word, lno), lno, cno], [',', ',', lno, cno]);\n      }\n      tokens.splice.apply(tokens, [i, 1].concat(slice$.call(ts), [[']', ']', lno, cno]]));\n      i += ts.length;\n      break;\n    case 'INDENT':\n      if (that = tokens[i - 1]) {\n        if (that[1] === 'new') {\n          tokens.splice(i++, 0, ['PARAM(', '', token[2], token[3]], [')PARAM', '', token[2], token[3]], ['->', '', token[2], token[3]]);\n        } else if ((ref7$ = that[0]) === 'FUNCTION' || ref7$ === 'GENERATOR' || ref7$ === 'LET') {\n          tokens.splice(i, 0, ['CALL(', '', token[2], token[3]], [')CALL', '', token[2], token[3]]);\n          i += 2;\n        }\n      }\n      continue;\n    case 'LITERAL':\n    case '}':\n      break;\n    case ')':\n    case ')CALL':\n      if (token[1]) {\n        continue;\n      }\n      break;\n    case ']':\n      if (token.index) {\n        continue;\n      }\n      break;\n    case 'CREMENT':\n      if (!able(tokens, i)) {\n        continue;\n      }\n      break;\n    case 'BIOP':\n      if (!token.spaced && ((ref7$ = token[1]) === '+' || ref7$ === '-') && tokens[i + 1][0] !== ')') {\n        tokens[i][0] = '+-';\n      }\n      continue;\n    default:\n      continue;\n    }\n    if (token.spaced && in$(tokens[i + 1][0], ARG)) {\n      tokens.splice(++i, 0, [',', ',', token[2], token[3]]);\n    }\n  }\n  function fn$(){\n    if (0x10000 < ts.push(['STRNUM', enc(n), lno, cno], [',', ',', lno, cno])) {\n      carp('range limit exceeded', lno);\n    }\n  }\n}\nfunction detectEnd(tokens, i, ok, go){\n  var levels, token, tag;\n  levels = 0;\n  for (; token = tokens[i]; ++i) {\n    if (!levels && ok(token, i)) {\n      return go(token, i);\n    }\n    tag = token[0];\n    if (0 > (levels += in$(tag, OPENERS) || -in$(tag, CLOSERS))) {\n      return go(token, i);\n    }\n  }\n}\nfunction indexOfPair(tokens, i){\n  var level, end, start, that;\n  level = 1;\n  end = INVERSES[start = tokens[i][0]];\n  while (that = tokens[++i]) {\n    switch (that[0]) {\n    case start:\n      ++level;\n      break;\n    case end:\n      if (!--level) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\nKEYWORDS_SHARED = ['true', 'false', 'null', 'this', 'void', 'super', 'return', 'throw', 'break', 'continue', 'if', 'else', 'for', 'while', 'switch', 'case', 'default', 'try', 'catch', 'finally', 'function', 'class', 'extends', 'implements', 'new', 'do', 'delete', 'typeof', 'in', 'instanceof', 'let', 'with', 'var', 'const', 'import', 'export', 'debugger', 'yield'];\nKEYWORDS_UNUSED = ['enum', 'interface', 'package', 'private', 'protected', 'public', 'static'];\nJS_KEYWORDS = KEYWORDS_SHARED.concat(KEYWORDS_UNUSED);\nLS_KEYWORDS = ['xor', 'match', 'where'];\nID = /((?!\\s)[a-z_$\\xAA-\\uFFDC](?:(?!\\s)[\\w$\\xAA-\\uFFDC]|-[a-z])*)([^\\n\\S]*:(?![:=]))?|/ig;\nSYMBOL = /[-\\/^]=|[%+:*]{1,2}=|\\|>=|\\.(?:[&\\|\\^]|<<|>>>?)\\.=?|\\.{1,3}|\\^\\^|\\*?<(?:--?|~~?)!?|!?(?:--?|~~?)>\\*?|([-+&|:])\\1|%%|&|\\([^\\n\\S]*\\)|[!=]==?|!?\\~=|@@?|<\\[(?:[\\s\\S]*?\\]>)?|<<<<?|<\\||[<>]==|<<=|>>=|<<|>>|[<>]\\??=?|\\|>|\\||=>|\\*\\*|\\^|`|[^\\s#]?/g;\nSPACE = /[^\\n\\S]*(?:#.*)?/g;\nMULTIDENT = /(?:\\s*#.*)*(?:\\n([^\\n\\S]*))*/g;\nSIMPLESTR = /'[^\\\\']*(?:\\\\[\\s\\S][^\\\\']*)*'|/g;\nJSTOKEN = /``[^\\\\`]*(?:\\\\[\\s\\S][^\\\\`]*)*``|/g;\nBSTOKEN = RegExp('\\\\\\\\(?:(\\\\S[^\\\\s,;)}\\\\]]*)|(?:' + SPACE.source + '\\\\n?)*)', 'g');\nNUMBER = /0x[\\dA-Fa-f][\\dA-Fa-f_]*|(\\d*)~([\\dA-Za-z]\\w*)|((\\d[\\d_]*)(\\.\\d[\\d_]*)?(?:e[+-]?\\d[\\d_]*)?)[$\\w]*|/g;\nNUMBER_OMIT = /_+/g;\nREGEX = /\\/([^[\\/\\n\\\\]*(?:(?:\\\\.|\\[[^\\]\\n\\\\]*(?:\\\\.[^\\]\\n\\\\]*)*\\])[^[\\/\\n\\\\]*)*)\\/([gimy]{1,4}|\\$?)|/g;\nHEREGEX_OMIT = /\\s+(?:#.*)?/g;\nLASTDENT = /\\n[^\\n\\S]*$/;\nINLINEDENT = /[^\\n\\S]*[^#\\s]?/g;\nNONASCII = /[\\x80-\\uFFFF]/;\nOPENERS = ['(', '[', '{', 'CALL(', 'PARAM(', 'INDENT'];\nCLOSERS = [')', ']', '}', ')CALL', ')PARAM', 'DEDENT'];\nINVERSES = import$((function(){\n  var i$, ref$, len$, resultObj$ = {};\n  for (i$ = 0, len$ = (ref$ = OPENERS).length; i$ < len$; ++i$) {\n    i = i$;\n    o = ref$[i$];\n    resultObj$[o] = CLOSERS[i];\n  }\n  return resultObj$;\n}()), (function(){\n  var i$, ref$, len$, resultObj$ = {};\n  for (i$ = 0, len$ = (ref$ = CLOSERS).length; i$ < len$; ++i$) {\n    i = i$;\n    c = ref$[i$];\n    resultObj$[c] = OPENERS[i];\n  }\n  return resultObj$;\n}()));\nCHAIN = ['(', '{', '[', 'ID', 'STRNUM', 'LITERAL', 'LET', 'WITH', 'WORDS'];\nARG = CHAIN.concat(['...', 'UNARY', 'YIELD', 'CREMENT', 'PARAM(', 'FUNCTION', 'GENERATOR', 'IF', 'SWITCH', 'TRY', 'CLASS', 'RANGE', 'LABEL', 'DECL', 'DO', 'BIOPBP']);\nBLOCK_USERS = [',', ':', '->', 'ELSE', 'ASSIGN', 'IMPORT', 'UNARY', 'DEFAULT', 'TRY', 'FINALLY', 'HURL', 'DECL', 'DO', 'LET', 'FUNCTION', 'GENERATOR', '...'];\nfunction clone$(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}\nfunction in$(x, xs){\n  var i = -1, l = xs.length >>> 0;\n  while (++i < l) if (x === xs[i]) return true;\n  return false;\n}\nfunction import$(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n  return obj;\n}","/home/travis/build/npmtest/node-npmtest-livescript/node_modules/livescript/lib/parser.js":"/* parser generated by jison 0.4.17 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[2,61],$V1=[1,31],$V2=[1,34],$V3=[1,35],$V4=[1,36],$V5=[1,37],$V6=[1,38],$V7=[1,39],$V8=[1,8],$V9=[1,15],$Va=[1,14],$Vb=[1,40],$Vc=[1,41],$Vd=[1,29],$Ve=[1,6],$Vf=[1,10],$Vg=[1,9],$Vh=[1,11],$Vi=[1,16],$Vj=[1,17],$Vk=[1,18],$Vl=[1,19],$Vm=[1,20],$Vn=[1,21],$Vo=[1,23],$Vp=[1,42],$Vq=[1,24],$Vr=[1,25],$Vs=[1,26],$Vt=[1,27],$Vu=[1,28],$Vv=[1,30],$Vw=[1,43],$Vx=[1,22,27,46],$Vy=[22,46],$Vz=[2,65],$VA=[1,47],$VB=[1,48],$VC=[1,49],$VD=[1,50],$VE=[1,51],$VF=[1,52],$VG=[1,53],$VH=[1,54],$VI=[1,55],$VJ=[1,56],$VK=[1,57],$VL=[1,58],$VM=[1,59],$VN=[1,60],$VO=[1,61],$VP=[32,45,46,47],$VQ=[2,51],$VR=[1,66],$VS=[1,65],$VT=[1,68],$VU=[1,14,21,22,24,26,27,28,32,35,36,37,40,45,46,47,57,58,61,62,63,64,65,66,67,68,69,70,71,78,81,82,104],$VV=[2,76],$VW=[1,75],$VX=[1,76],$VY=[1,77],$VZ=[1,72],$V_=[1,70],$V$=[1,71],$V01=[1,73],$V11=[1,74],$V21=[1,81],$V31=[1,85],$V41=[1,84],$V51=[1,82],$V61=[1,93],$V71=[1,106],$V81=[47,104],$V91=[2,209],$Va1=[1,110],$Vb1=[2,1],$Vc1=[1,9,11,14,15,21,22,24,26,27,28,32,34,35,36,37,40,45,46,47,55,56,57,58,61,62,63,64,65,66,67,68,69,70,71,72,78,81,82,96,102,103,104],$Vd1=[21,45,46,47],$Ve1=[24,45,46],$Vf1=[2,164],$Vg1=[1,132],$Vh1=[1,133],$Vi1=[1,130],$Vj1=[1,131],$Vk1=[1,134],$Vl1=[1,122],$Vm1=[1,126],$Vn1=[1,127],$Vo1=[1,125],$Vp1=[27,46],$Vq1=[1,148],$Vr1=[1,149],$Vs1=[32,46,47],$Vt1=[2,59],$Vu1=[1,171],$Vv1=[14,21,22,32,45,46,47],$Vw1=[2,56],$Vx1=[2,72],$Vy1=[14,45,46,47],$Vz1=[1,14,21,22,24,26,27,28,32,36,37,40,45,46,47,57,58,61,62,63,65,66,67,69,70,71,78,81,82,104],$VA1=[22,45,46,47],$VB1=[1,14,21,22,24,26,27,28,32,36,37,40,45,46,47,78,81,82,104],$VC1=[2,173],$VD1=[1,203],$VE1=[1,207],$VF1=[1,14,21,22,24,26,27,28,32,35,36,37,40,45,46,47,57,58,61,62,63,64,65,66,67,68,69,70,71,78,81,104],$VG1=[1,210],$VH1=[45,47,82],$VI1=[2,211],$VJ1=[1,216],$VK1=[1,14,21,22,24,26,27,28,32,36,37,40,45,46,47,70,71,78,81,82,104],$VL1=[1,223],$VM1=[21,46,47],$VN1=[24,46],$VO1=[1,229],$VP1=[22,24,45,46],$VQ1=[1,231],$VR1=[22,24,45,46,56,62],$VS1=[1,9,11,14,15,21,22,24,26,27,28,32,34,35,36,37,40,45,46,47,55,56,57,58,61,62,63,64,65,66,67,68,69,70,71,72,78,81,82,96,100,102,103,104],$VT1=[1,259],$VU1=[1,258],$VV1=[21,22,24,40,46,47,81],$VW1=[1,14,21,22,24,26,27,28,32,36,37,40,45,46,47,57,61,62,65,66,67,69,70,71,78,81,82,104],$VX1=[1,14,21,22,24,26,27,28,32,36,37,40,45,46,47,62,66,70,71,78,81,82,104],$VY1=[1,14,21,22,24,26,27,28,32,36,37,40,45,46,47,61,62,66,69,70,71,78,81,82,104],$VZ1=[1,270],$V_1=[1,271],$V$1=[2,60],$V02=[14,46,47],$V12=[22,46,47],$V22=[1,308],$V32=[1,309],$V42=[1,318],$V52=[1,348],$V62=[1,349],$V72=[1,14,21,22,24,26,27,28,32,35,36,37,40,45,46,47,57,58,61,62,63,64,65,66,67,68,69,70,71,78,81,82,88,89,104],$V82=[1,423];\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"Chain\":3,\"ID\":4,\"Parenthetical\":5,\"List\":6,\"STRNUM\":7,\"LITERAL\":8,\"DOT\":9,\"Key\":10,\"CALL(\":11,\"ArgList\":12,\"OptComma\":13,\")CALL\":14,\"?\":15,\"LET\":16,\"Block\":17,\"[\":18,\"Expression\":19,\"LoopHeads\":20,\"]\":21,\"DEDENT\":22,\"{\":23,\"}\":24,\"(\":25,\"BIOP\":26,\")\":27,\"BIOPR\":28,\"BIOPBP\":29,\"BIOPP\":30,\"PARAM(\":31,\")PARAM\":32,\"UNARY\":33,\"CREMENT\":34,\"BACKTICK\":35,\"TO\":36,\"BY\":37,\"FROM\":38,\"WITH\":39,\"FOR\":40,\"Properties\":41,\"LABEL\":42,\"KeyBase\":43,\"Arg\":44,\",\":45,\"NEWLINE\":46,\"INDENT\":47,\"...\":48,\"Lines\":49,\"Line\":50,\"<-\":51,\"COMMENT\":52,\"REQUIRE\":53,\"SplatChain\":54,\"CLONEPORT\":55,\"ASSIGN\":56,\"IMPORT\":57,\"+-\":58,\"CLONE\":59,\"YIELD\":60,\"COMPARE\":61,\"LOGIC\":62,\"MATH\":63,\"POWER\":64,\"SHIFT\":65,\"BITWISE\":66,\"CONCAT\":67,\"COMPOSE\":68,\"RELATION\":69,\"PIPE\":70,\"BACKPIPE\":71,\"!?\":72,\"->\":73,\"FUNCTION\":74,\"GENERATOR\":75,\"IF\":76,\"Else\":77,\"POST_IF\":78,\"LoopHead\":79,\"DO\":80,\"WHILE\":81,\"CASE\":82,\"HURL\":83,\"JUMP\":84,\"SWITCH\":85,\"Exprs\":86,\"Cases\":87,\"DEFAULT\":88,\"ELSE\":89,\"TRY\":90,\"CATCH\":91,\"FINALLY\":92,\"CLASS\":93,\"OptExtends\":94,\"OptImplements\":95,\"EXTENDS\":96,\"DECL\":97,\"KeyValue\":98,\"Property\":99,\":\":100,\"Body\":101,\"IN\":102,\"OF\":103,\"IMPLEMENTS\":104,\"Root\":105,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",4:\"ID\",7:\"STRNUM\",8:\"LITERAL\",9:\"DOT\",11:\"CALL(\",14:\")CALL\",15:\"?\",16:\"LET\",18:\"[\",21:\"]\",22:\"DEDENT\",23:\"{\",24:\"}\",25:\"(\",26:\"BIOP\",27:\")\",28:\"BIOPR\",29:\"BIOPBP\",30:\"BIOPP\",31:\"PARAM(\",32:\")PARAM\",33:\"UNARY\",34:\"CREMENT\",35:\"BACKTICK\",36:\"TO\",37:\"BY\",38:\"FROM\",39:\"WITH\",40:\"FOR\",42:\"LABEL\",45:\",\",46:\"NEWLINE\",47:\"INDENT\",48:\"...\",51:\"<-\",52:\"COMMENT\",53:\"REQUIRE\",55:\"CLONEPORT\",56:\"ASSIGN\",57:\"IMPORT\",58:\"+-\",59:\"CLONE\",60:\"YIELD\",61:\"COMPARE\",62:\"LOGIC\",63:\"MATH\",64:\"POWER\",65:\"SHIFT\",66:\"BITWISE\",67:\"CONCAT\",68:\"COMPOSE\",69:\"RELATION\",70:\"PIPE\",71:\"BACKPIPE\",72:\"!?\",73:\"->\",74:\"FUNCTION\",75:\"GENERATOR\",76:\"IF\",78:\"POST_IF\",80:\"DO\",81:\"WHILE\",82:\"CASE\",83:\"HURL\",84:\"JUMP\",85:\"SWITCH\",88:\"DEFAULT\",89:\"ELSE\",90:\"TRY\",91:\"CATCH\",92:\"FINALLY\",93:\"CLASS\",96:\"EXTENDS\",97:\"DECL\",100:\":\",102:\"IN\",103:\"OF\",104:\"IMPLEMENTS\"},\nproductions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\nthis.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));\nbreak;\ncase 2: case 3:\nthis.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));\nbreak;\ncase 4: case 5:\nthis.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));\nbreak;\ncase 6: case 7:\nthis.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));\nbreak;\ncase 8:\nthis.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));\nbreak;\ncase 9:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));\nbreak;\ncase 10:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call['let']($$[$0-3], $$[$0]))));\nbreak;\ncase 11:\nthis.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));\nbreak;\ncase 12:\nthis.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));\nbreak;\ncase 13:\nthis.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));\nbreak;\ncase 14: case 20: case 22:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));\nbreak;\ncase 15:\nthis.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));\nbreak;\ncase 16:\nthis.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));\nbreak;\ncase 17:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],'!' === $$[$0-1].charAt(0)\n        ? yy.Binary($$[$0-1].slice(1)).invertIt()\n        : yy.Binary($$[$0-1]))));\nbreak;\ncase 18:\nthis.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],'!' === $$[$0-2].charAt(0)\n        ? yy.Binary($$[$0-2].slice(1), void 8, $$[$0-1]).invertIt()\n        : yy.Binary($$[$0-2], void 8, $$[$0-1]))));\nbreak;\ncase 19:\nthis.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],'!' === $$[$0-1].charAt(0)\n        ? yy.Binary($$[$0-1].slice(1), $$[$0-2]).invertIt()\n        : yy.Binary($$[$0-1], $$[$0-2]))));\nbreak;\ncase 21:\nthis.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-5],yy.Binary($$[$0-5], void 8, $$[$0-3]))));\nbreak;\ncase 23:\nthis.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-4]))));\nbreak;\ncase 24: case 25:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Unary($$[$0-1]))));\nbreak;\ncase 26:\nthis.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));\nbreak;\ncase 27:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));\nbreak;\ncase 28:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var('flip$'))).add(yy.L(_$[$0-3],_$[$0-3],yy.Call([$$[$0-3]])))).flipIt().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));\nbreak;\ncase 29:\nthis.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.For({\n        from: $$[$0-3],\n        op: $$[$0-2],\n        to: $$[$0-1],\n        inComprehension: true\n      }))));\nbreak;\ncase 30:\nthis.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], new yy.For({\n        from: $$[$0-5],\n        op: $$[$0-4],\n        to: $$[$0-3],\n        step: $$[$0-1],\n        inComprehension: true\n      }))));\nbreak;\ncase 31:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], new yy.For({\n        from: $$[$0-3],\n        op: $$[$0-2],\n        to: $$[$0-1],\n        inComprehension: true\n      }))));\nbreak;\ncase 32:\nthis.$ = yy.L(_$[$0-7], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0-1], new yy.For({\n        from: $$[$0-5],\n        op: $$[$0-4],\n        to: $$[$0-3],\n        step: $$[$0-1],\n        inComprehension: true\n      }))));\nbreak;\ncase 33:\nthis.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], new yy.For({\n        from: yy.Chain(yy.Literal(0)),\n        op: $$[$0-2],\n        to: $$[$0-1],\n        inComprehension: true\n      }))));\nbreak;\ncase 34:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], new yy.For({\n        from: yy.Chain(yy.Literal(0)),\n        op: $$[$0-4],\n        to: $$[$0-3],\n        step: $$[$0-1],\n        inComprehension: true\n      }))));\nbreak;\ncase 35:\nthis.$ = yy.L(_$[$0-8], _$[$0],yy.Chain(yy.L(_$[$0-8],_$[$0], new yy.StepSlice({\n        op: $$[$0-4],\n        target: $$[$0-8],\n        from: $$[$0-5],\n        to: $$[$0-3],\n        step: $$[$0-1]\n      }))));\nbreak;\ncase 36:\nthis.$ = yy.L(_$[$0-7], _$[$0],yy.Chain(yy.L(_$[$0-7],_$[$0], new yy.StepSlice({\n        op: $$[$0-4],\n        target: $$[$0-7],\n        from: yy.Literal(0),\n        to: $$[$0-3],\n        step: $$[$0-1]\n      }))));\nbreak;\ncase 37:\nthis.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], yy.Slice({\n        type: $$[$0-2],\n        target: $$[$0-6],\n        from: $$[$0-3],\n        to: $$[$0-1]\n      }))));\nbreak;\ncase 38:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0], yy.Slice({\n        type: $$[$0-1],\n        target: $$[$0-5],\n        from: $$[$0-2]\n      }))));\nbreak;\ncase 39:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0], yy.Slice({\n        type: $$[$0-2],\n        target: $$[$0-5],\n        to: $$[$0-1]\n      }))));\nbreak;\ncase 40:\nthis.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], yy.Slice({\n        type: $$[$0-1],\n        target: $$[$0-4]\n      }))));\nbreak;\ncase 41:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], yy.Cascade($$[$0-1], $$[$0], 'with'))));\nbreak;\ncase 42:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], new yy.For({\n        kind: $$[$0-2],\n        source: $$[$0-1],\n        body: $$[$0],\n        ref: true\n      }).addBody($$[$0]))));\nbreak;\ncase 43:\nthis.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));\nbreak;\ncase 44:\nthis.$ = yy.L(_$[$0-3], _$[$0],yy.Obj($$[$0-2]));\nbreak;\ncase 45:\nthis.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).named($$[$0]));\nbreak;\ncase 46:\nthis.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));\nbreak;\ncase 47: case 48: case 56: case 59: case 60: case 64: case 65: case 149: case 157: case 170: case 171:\n\nbreak;\ncase 49:\nthis.$ = yy.L(_$[$0], _$[$0],yy.Key($$[$0]));\nbreak;\ncase 50:\nthis.$ = yy.L(_$[$0], _$[$0],yy.Literal($$[$0]));\nbreak;\ncase 51: case 164:\nthis.$ = yy.L(_$[$0], _$[$0],[]);\nbreak;\ncase 52: case 147: case 165: case 202:\nthis.$ = yy.L(_$[$0], _$[$0],[$$[$0]]);\nbreak;\ncase 53: case 148: case 166: case 204: case 205:\nthis.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].concat($$[$0]));\nbreak;\ncase 54: case 167:\nthis.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat($$[$0]));\nbreak;\ncase 55:\nthis.$ = yy.L(_$[$0-5], _$[$0-2],$$[$0-5].concat($$[$0-2]));\nbreak;\ncase 57: case 162:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0]));\nbreak;\ncase 58:\nthis.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));\nbreak;\ncase 61:\nthis.$ = yy.L(_$[$0], _$[$0],yy.Block());\nbreak;\ncase 62:\nthis.$ = yy.L(_$[$0], _$[$0],yy.Block($$[$0]));\nbreak;\ncase 63: case 172:\nthis.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add($$[$0]));\nbreak;\ncase 66:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Cascade($$[$0-1], $$[$0], 'cascade'));\nbreak;\ncase 67:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\\*/.test($$[$0-1])));\nbreak;\ncase 68: case 163:\nthis.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));\nbreak;\ncase 69:\nthis.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS(\"Error('unimplemented')\"))));\nbreak;\ncase 70:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));\nbreak;\ncase 71:\nthis.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);\nbreak;\ncase 72:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));\nbreak;\ncase 73:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary('^^', $$[$0-2], {\n        prec: 'yy.UNARY'\n      })), $$[$0], false));\nbreak;\ncase 74:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary('^^', $$[$0-2], {\n        prec: 'yy.UNARY'\n      })), $$[$0].unwrap(), false));\nbreak;\ncase 75:\nthis.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));\nbreak;\ncase 76:\nthis.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());\nbreak;\ncase 77:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));\nbreak;\ncase 78:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));\nbreak;\ncase 79:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));\nbreak;\ncase 80:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Import($$[$0-2], $$[$0], $$[$0-1] === '<<<<'));\nbreak;\ncase 81:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Import($$[$0-5], yy.Arr.maybe($$[$0-2]), $$[$0-4] === '<<<<'));\nbreak;\ncase 82:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0-1], $$[$0].unwrap()));\nbreak;\ncase 83:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0], $$[$0-1].unwrap(), true));\nbreak;\ncase 84:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Unary($$[$0-2], yy.Splat($$[$0].unwrap())));\nbreak;\ncase 85:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0], $$[$0-1], true));\nbreak;\ncase 86: case 87: case 88:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0].unwrap(), [$$[$0-2]], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));\nbreak;\ncase 89: case 90: case 91:\nthis.$ = yy.L(_$[$0-3], _$[$0],yy.Assign(yy.Splat($$[$0].unwrap()), [$$[$0-3]], yy.L(_$[$0-2],_$[$0-2],yy.Box($$[$0-2]))));\nbreak;\ncase 92: case 93: case 94:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0-1], $$[$0]));\nbreak;\ncase 95: case 96: case 97:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Unary($$[$0-2], yy.Splat($$[$0])));\nbreak;\ncase 98:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Unary($$[$0-5], yy.Splat(yy.Arr($$[$0-2]))));\nbreak;\ncase 99:\nthis.$ = yy.L(_$[$0-4], _$[$0],yy.Unary($$[$0-4], yy.Arr.maybe($$[$0-2])));\nbreak;\ncase 100:\nthis.$ = yy.L(_$[$0], _$[$0],yy.Yield($$[$0]));\nbreak;\ncase 101:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Yield($$[$0-1], $$[$0]));\nbreak;\ncase 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 158:\nthis.$ = (yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2], $$[$0])));\nbreak;\ncase 111:\nthis.$ = yy.L(_$[$0-2], _$[$0],'!' === $$[$0-1].charAt(0)\n        ? yy.Binary($$[$0-1].slice(1), $$[$0-2], $$[$0]).invert()\n        : yy.Binary($$[$0-1], $$[$0-2], $$[$0]));\nbreak;\ncase 112:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe($$[$0], $$[$0-1]));\nbreak;\ncase 113:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe([$$[$0]], $$[$0-1]));\nbreak;\ncase 114:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Existence($$[$0-1].unwrap(), true));\nbreak;\ncase 115:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\\*/.test($$[$0-1])));\nbreak;\ncase 116:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));\nbreak;\ncase 117:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true).named($$[$0-5]));\nbreak;\ncase 118:\nthis.$ = (yy.L(_$[$0-3],_$[$0-2], yy.If($$[$0-2], $$[$0-1], $$[$0-3] === 'unless')).addElse($$[$0]));\nbreak;\ncase 119:\nthis.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === 'unless')));\nbreak;\ncase 120:\nthis.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));\nbreak;\ncase 121:\nthis.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0], $$[$0-1] === 'until', true).addBody($$[$0-2]));\nbreak;\ncase 122:\nthis.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until', true).addGuard($$[$0]).addBody($$[$0-4]));\nbreak;\ncase 123:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));\nbreak;\ncase 124:\nthis.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));\nbreak;\ncase 125:\nthis.$ = yy.L(_$[$0], _$[$0],yy.Jump[$$[$0]]());\nbreak;\ncase 126:\nthis.$ = yy.L(_$[$0], _$[$0],new yy.Jump($$[$0]));\nbreak;\ncase 127:\nthis.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));\nbreak;\ncase 128:\nthis.$ = yy.L(_$[$0-2], _$[$0],new yy.Switch($$[$0-2], $$[$0-1], $$[$0]));\nbreak;\ncase 129: case 130:\nthis.$ = yy.L(_$[$0-4], _$[$0],new yy.Switch($$[$0-4], $$[$0-3], $$[$0-2], $$[$0]));\nbreak;\ncase 131:\nthis.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, $$[$0]));\nbreak;\ncase 132: case 133:\nthis.$ = yy.L(_$[$0-3], _$[$0],new yy.Switch($$[$0-3], null, $$[$0-2], $$[$0]));\nbreak;\ncase 134:\nthis.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, [], $$[$0]));\nbreak;\ncase 135:\nthis.$ = yy.L(_$[$0-1], _$[$0],new yy.Try($$[$0]));\nbreak;\ncase 136:\nthis.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));\nbreak;\ncase 137:\nthis.$ = yy.L(_$[$0-5], _$[$0],new yy.Try($$[$0-4], void 8, yy.L(_$[$0-3],_$[$0-3],$$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));\nbreak;\ncase 138:\nthis.$ = yy.L(_$[$0-4], _$[$0],new yy.Try($$[$0-3], $$[$0-1], yy.L(_$[$0-2],_$[$0-1], $$[$0])));\nbreak;\ncase 139:\nthis.$ = yy.L(_$[$0-6], _$[$0],new yy.Try($$[$0-5], $$[$0-3], yy.L(_$[$0-4],_$[$0-3], $$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));\nbreak;\ncase 140:\nthis.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));\nbreak;\ncase 141:\nthis.$ = yy.L(_$[$0-4], _$[$0],new yy.Class({\n        title: $$[$0-3].unwrap(),\n        sup: $$[$0-2],\n        mixins: $$[$0-1],\n        body: $$[$0]\n      }));\nbreak;\ncase 142:\nthis.$ = yy.L(_$[$0-3], _$[$0],new yy.Class({\n        sup: $$[$0-2],\n        mixins: $$[$0-1],\n        body: $$[$0]\n      }));\nbreak;\ncase 143:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));\nbreak;\ncase 144: case 145:\nthis.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));\nbreak;\ncase 146:\nthis.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));\nbreak;\ncase 150:\nthis.$ = yy.L(_$[$0], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== 'arguments' && $$[$0] !== 'eval')), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));\nbreak;\ncase 151:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain($$[$0-2], [yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1]))])));\nbreak;\ncase 152:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Literal($$[$0-2])), [yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1]))])));\nbreak;\ncase 153:\nthis.$ = yy.L(_$[$0-4], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0])), yy.L(_$[$0-4],_$[$0-1], yy.Obj($$[$0-3]).named($$[$0]))));\nbreak;\ncase 154:\nthis.$ = yy.L(_$[$0-4], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0])), yy.L(_$[$0-4],_$[$0-1], yy.Arr($$[$0-3]).named($$[$0]))));\nbreak;\ncase 155:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0-2], $$[$0]));\nbreak;\ncase 156:\nthis.$ = yy.L(_$[$0-5], _$[$0],yy.Prop($$[$0-5], yy.Arr.maybe($$[$0-2])));\nbreak;\ncase 159:\nthis.$ = (yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2], $$[$0], true)));\nbreak;\ncase 160:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Prop($$[$0].maybeKey(), yy.L(_$[$0-1],_$[$0-1],yy.Literal($$[$0-1] === '+'))));\nbreak;\ncase 161:\nthis.$ = yy.L(_$[$0-1], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], true)), yy.L(_$[$0-1],_$[$0-1],yy.Literal($$[$0-1] === '+'))));\nbreak;\ncase 168:\nthis.$ = yy.L(_$[$0-3], _$[$0],$$[$0-2]);\nbreak;\ncase 169:\nthis.$ = yy.L(_$[$0-2], _$[$0],yy.Parens($$[$0-1].chomp().unwrap(), false, $$[$0-2] === '\"', yy.L(_$[$0-2],_$[$0-2],{}), yy.L(_$[$0],_$[$0],{})));\nbreak;\ncase 173: case 209: case 211:\nthis.$ = yy.L(_$[$0], _$[$0],null);\nbreak;\ncase 174: case 208: case 210:\nthis.$ = yy.L(_$[$0-1], _$[$0],$$[$0]);\nbreak;\ncase 175:\nthis.$ = yy.L(_$[$0-4], _$[$0],yy.If($$[$0-2], $$[$0-1], $$[$0-3] === 'unless').addElse($$[$0]));\nbreak;\ncase 176:\nthis.$ = yy.L(_$[$0-3], _$[$0],new yy.For({\n        kind: $$[$0-3],\n        item: $$[$0-2].unwrap(),\n        index: $$[$0-1],\n        source: $$[$0]\n      }));\nbreak;\ncase 177:\nthis.$ = yy.L(_$[$0-5], _$[$0],new yy.For({\n        kind: $$[$0-5],\n        item: $$[$0-4].unwrap(),\n        index: $$[$0-3],\n        source: $$[$0-2],\n        guard: $$[$0]\n      }));\nbreak;\ncase 178:\nthis.$ = yy.L(_$[$0-5], _$[$0],new yy.For({\n        kind: $$[$0-5],\n        item: $$[$0-4].unwrap(),\n        index: $$[$0-3],\n        source: $$[$0-2],\n        step: $$[$0]\n      }));\nbreak;\ncase 179:\nthis.$ = yy.L(_$[$0-7], _$[$0],new yy.For({\n        kind: $$[$0-7],\n        item: $$[$0-6].unwrap(),\n        index: $$[$0-5],\n        source: $$[$0-4],\n        step: $$[$0-2],\n        guard: $$[$0]\n      }));\nbreak;\ncase 180:\nthis.$ = yy.L(_$[$0-1], _$[$0],new yy.For({\n        kind: $$[$0-1],\n        source: $$[$0],\n        ref: true\n      }));\nbreak;\ncase 181:\nthis.$ = yy.L(_$[$0-3], _$[$0],new yy.For({\n        kind: $$[$0-3],\n        source: $$[$0-2],\n        ref: true,\n        guard: $$[$0]\n      }));\nbreak;\ncase 182:\nthis.$ = yy.L(_$[$0-3], _$[$0],new yy.For({\n        kind: $$[$0-3],\n        source: $$[$0-2],\n        ref: true,\n        step: $$[$0]\n      }));\nbreak;\ncase 183:\nthis.$ = yy.L(_$[$0-5], _$[$0],new yy.For({\n        kind: $$[$0-5],\n        source: $$[$0-4],\n        ref: true,\n        step: $$[$0-2],\n        guard: $$[$0]\n      }));\nbreak;\ncase 184:\nthis.$ = yy.L(_$[$0-3], _$[$0],new yy.For({\n        object: true,\n        kind: $$[$0-3],\n        index: $$[$0-2],\n        source: $$[$0]\n      }));\nbreak;\ncase 185:\nthis.$ = yy.L(_$[$0-5], _$[$0],new yy.For({\n        object: true,\n        kind: $$[$0-5],\n        index: $$[$0-4],\n        source: $$[$0-2],\n        guard: $$[$0]\n      }));\nbreak;\ncase 186:\nthis.$ = yy.L(_$[$0-5], _$[$0],new yy.For({\n        object: true,\n        kind: $$[$0-5],\n        index: $$[$0-4],\n        item: $$[$0-2].unwrap(),\n        source: $$[$0]\n      }));\nbreak;\ncase 187:\nthis.$ = yy.L(_$[$0-7], _$[$0],new yy.For({\n        object: true,\n        kind: $$[$0-7],\n        index: $$[$0-6],\n        item: $$[$0-4].unwrap(),\n        source: $$[$0-2],\n        guard: $$[$0]\n      }));\nbreak;\ncase 188:\nthis.$ = yy.L(_$[$0-5], _$[$0],new yy.For({\n        kind: $$[$0-5],\n        index: $$[$0-4],\n        from: $$[$0-2],\n        op: $$[$0-1],\n        to: $$[$0]\n      }));\nbreak;\ncase 189:\nthis.$ = yy.L(_$[$0-4], _$[$0],new yy.For({\n        kind: $$[$0-4],\n        from: $$[$0-2],\n        op: $$[$0-1],\n        to: $$[$0],\n        ref: true\n      }));\nbreak;\ncase 190:\nthis.$ = yy.L(_$[$0-7], _$[$0],new yy.For({\n        kind: $$[$0-7],\n        index: $$[$0-6],\n        from: $$[$0-4],\n        op: $$[$0-3],\n        to: $$[$0-2],\n        guard: $$[$0]\n      }));\nbreak;\ncase 191:\nthis.$ = yy.L(_$[$0-6], _$[$0],new yy.For({\n        kind: $$[$0-6],\n        from: $$[$0-4],\n        op: $$[$0-3],\n        to: $$[$0-2],\n        guard: $$[$0],\n        ref: true\n      }));\nbreak;\ncase 192:\nthis.$ = yy.L(_$[$0-7], _$[$0],new yy.For({\n        kind: $$[$0-7],\n        index: $$[$0-6],\n        from: $$[$0-4],\n        op: $$[$0-3],\n        to: $$[$0-2],\n        step: $$[$0]\n      }));\nbreak;\ncase 193:\nthis.$ = yy.L(_$[$0-6], _$[$0],new yy.For({\n        kind: $$[$0-6],\n        from: $$[$0-4],\n        op: $$[$0-3],\n        to: $$[$0-2],\n        step: $$[$0],\n        ref: true\n      }));\nbreak;\ncase 194:\nthis.$ = yy.L(_$[$0-9], _$[$0],new yy.For({\n        kind: $$[$0-9],\n        index: $$[$0-8],\n        from: $$[$0-6],\n        op: $$[$0-5],\n        to: $$[$0-4],\n        step: $$[$0-2],\n        guard: $$[$0]\n      }));\nbreak;\ncase 195:\nthis.$ = yy.L(_$[$0-8], _$[$0],new yy.For({\n        kind: $$[$0-8],\n        from: $$[$0-6],\n        op: $$[$0-5],\n        to: $$[$0-4],\n        step: $$[$0-2],\n        guard: $$[$0],\n        ref: true\n      }));\nbreak;\ncase 196:\nthis.$ = yy.L(_$[$0-9], _$[$0],new yy.For({\n        kind: $$[$0-9],\n        index: $$[$0-8],\n        from: $$[$0-6],\n        op: $$[$0-5],\n        to: $$[$0-4],\n        guard: $$[$0-2],\n        step: $$[$0]\n      }));\nbreak;\ncase 197:\nthis.$ = yy.L(_$[$0-8], _$[$0],new yy.For({\n        kind: $$[$0-8],\n        from: $$[$0-6],\n        op: $$[$0-5],\n        to: $$[$0-4],\n        guard: $$[$0-2],\n        step: $$[$0],\n        ref: true\n      }));\nbreak;\ncase 198:\nthis.$ = yy.L(_$[$0-1], _$[$0],new yy.While($$[$0], $$[$0-1] === 'until'));\nbreak;\ncase 199:\nthis.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until').addGuard($$[$0]));\nbreak;\ncase 200:\nthis.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until', $$[$0]));\nbreak;\ncase 201:\nthis.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-4], $$[$0-5] === 'until', $$[$0-2]).addGuard($$[$0]));\nbreak;\ncase 203:\nthis.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1].concat($$[$0]));\nbreak;\ncase 206:\nthis.$ = yy.L(_$[$0-2], _$[$0],[yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))]);\nbreak;\ncase 207:\nthis.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat(yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))));\nbreak;\ncase 212:\nreturn this.$\nbreak;\n}\n},\ntable: [o([1,46],$V0,{105:1,101:2,49:3,17:4,50:5,19:7,3:12,54:13,79:22,5:32,6:33,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$V8,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,47:$Ve,48:$Vf,52:$Vg,53:$Vh,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),{1:[3]},{1:[2,212]},o($Vt,[2,170],{46:$Vw}),o($Vt,[2,171],{46:[1,44]}),o($Vx,[2,62]),o($Vy,$V0,{50:5,19:7,3:12,54:13,79:22,5:32,6:33,49:45,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$V8,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$Vf,52:$Vg,53:$Vh,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($Vx,$Vz,{17:46,35:$VA,47:$Ve,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VP,$VQ,{3:12,54:13,79:22,5:32,6:33,12:62,44:63,19:64,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($Vx,[2,68]),o($Vx,[2,69],{5:32,6:33,3:67,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT}),{3:69,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT},o($VU,$VV,{9:$VW,11:$VX,15:$VY,34:$VZ,55:$V_,56:$V$,72:$V01,96:$V11}),{34:[1,79],56:[1,78]},{3:80,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT,48:$V21},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:83,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,47:$V31,48:$V41,54:13,56:$V51,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:87,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:[1,88],54:13,56:[1,86],58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:90,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:[1,91],54:13,56:[1,89],58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o([1,14,21,22,24,26,27,28,32,35,36,37,45,46,47,57,61,62,63,64,65,66,67,68,69,70,71,78,82,104],[2,100],{3:12,54:13,79:22,5:32,6:33,19:92,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),{11:[1,94]},{11:[1,95]},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:96,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{17:97,47:$Ve},{17:98,47:$Ve},o([1,14,21,22,24,26,27,28,32,35,36,37,45,46,57,61,62,63,64,65,66,67,68,69,70,71,78,82,104],[2,125],{3:12,54:13,79:22,5:32,6:33,19:99,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,47:[1,100],48:$V61,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($VU,[2,126],{4:[1,101]}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,17:104,18:$V5,19:105,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,47:$Ve,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,82:$V71,83:$Vq,84:$Vr,85:$Vs,86:102,87:103,90:$Vt,93:$Vu,97:$Vv},{17:107,47:$Ve},o($V81,$V91,{5:32,6:33,3:108,94:109,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT,96:$Va1}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,17:112,18:$V5,19:111,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,47:$Ve,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{47:[1,113]},o([1,9,11,14,15,21,22,24,26,27,28,32,34,35,36,37,40,45,46,47,55,56,57,58,61,62,63,64,65,66,67,68,69,70,71,72,78,81,82,96,103,104],$Vb1),o($Vc1,[2,2]),o($Vc1,[2,3]),o($Vc1,[2,4]),o($Vc1,[2,5]),{11:[1,114]},o($Vd1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:115,12:118,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,36:[1,117],38:[1,116],39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($Ve1,$Vf1,{41:120,99:121,10:123,98:124,43:128,5:129,4:$Vg1,7:$Vh1,8:$Vi1,18:[1,119],23:$Vj1,25:$Vk1,47:$Vl1,48:$Vm1,52:$Vn1,58:$Vo1}),o($Vp1,$V0,{49:3,17:4,50:5,3:12,54:13,79:22,5:32,6:33,19:136,101:144,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,26:[1,135],28:[1,137],29:[1,138],30:[1,139],31:[1,140],33:[1,141],34:[1,142],35:[1,143],39:$Vb,40:$Vc,42:$Vd,47:$Ve,48:$Vf,52:$Vg,53:$Vh,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:145,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:147,4:$Vq1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:146,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,38:$Vr1,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:150,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($Vx,[2,64],{19:7,3:12,54:13,79:22,5:32,6:33,50:151,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$V8,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$Vf,52:$Vg,53:$Vh,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o([1,27,46],$V0,{50:5,19:7,3:12,54:13,79:22,5:32,6:33,49:152,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$V8,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$Vf,52:$Vg,53:$Vh,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),{22:[1,153],46:$Vw},o($Vx,[2,66]),{3:154,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:155,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,47:[1,156],48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:157,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:158,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:159,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:160,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:161,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:162,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:163,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:164,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:165,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:166,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:167,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:168,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:169,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($Vs1,$Vt1,{13:170,45:$Vu1}),o($Vv1,[2,52]),o($Vv1,$Vw1,{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($Vv1,[2,58],{54:13,79:22,5:32,6:33,19:172,3:173,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($VP,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:174,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o([34,56],$Vx1,{9:$VW,11:$VX,15:$VY}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:175,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($Vx,[2,70],{9:$VW,11:$VX,15:$VY}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,17:177,18:$V5,19:176,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,47:$Ve,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:178,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,47:[1,179],48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VU,[2,83]),o($VU,[2,114]),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:180,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{4:$Vg1,5:129,6:182,7:$Vh1,10:181,18:[1,183],23:[1,184],25:$Vk1,43:128},o($Vy1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:185,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($Vc1,[2,9]),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:186,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VU,[2,85]),o($VU,[2,82],{9:$VW,11:$VX,15:$VY}),{3:187,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT},{3:188,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT,48:[1,189]},o($Vz1,[2,92],{35:$VA,64:$VG,68:$VK}),{3:173,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:190,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,47:[1,191],48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VA1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:192,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),{3:193,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT,48:[1,194]},o($Vz1,[2,93],{35:$VA,64:$VG,68:$VK}),{3:173,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:195,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:196,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT,48:[1,197]},o($Vz1,[2,94],{35:$VA,64:$VG,68:$VK}),{3:173,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:198,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VB1,[2,101],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN}),{3:67,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT},o($Vy1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:199,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($Vy1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:200,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),{17:201,35:$VA,47:$Ve,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},o($VU,$VC1,{77:202,89:$VD1}),{81:[1,204]},o($VB1,[2,123],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN}),o($VA1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:205,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($VU,[2,127]),{45:$VE1,82:$V71,87:206},o($VF1,[2,131],{82:$VG1,88:[1,208],89:[1,209]}),o($VU,[2,134]),o($VH1,[2,147],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:105,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,86:211,90:$Vt,93:$Vu,97:$Vv},o($VU,[2,135],{91:[1,212],92:[1,213]}),o($V81,$V91,{94:214,9:$VW,11:$VX,15:$VY,96:$Va1}),{47:$VI1,95:215,104:$VJ1},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:217,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VK1,[2,144],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL}),o($VU,[2,145]),o($VA1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:218,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($Vy1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:219,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($Vd1,$Vw1,{20:220,79:222,35:$VA,36:[1,221],40:$VL1,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,81:$Vp}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:224,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:225,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VM1,$Vt1,{13:226,45:$Vu1}),o($Vd1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:227,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($VN1,$Vt1,{13:228,45:$VO1}),o($VP1,[2,165]),o([22,45,46],$Vf1,{99:121,10:123,98:124,43:128,5:129,41:230,4:$Vg1,7:$Vh1,8:$Vi1,18:$VQ1,23:$Vj1,25:$Vk1,47:$Vl1,48:$Vm1,52:$Vn1,58:$Vo1}),o($VR1,[2,149],{9:[1,233],100:[1,232]}),o($VP1,[2,157],{56:[1,235],62:[1,234]}),{4:$Vg1,5:129,7:$Vh1,8:[1,237],10:236,25:$Vk1,43:128},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:238,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VP1,[2,163]),o($VS1,[2,47]),o($VS1,[2,48]),o($VR1,[2,150],{9:[1,239]}),o($Ve1,$Vf1,{99:121,10:123,98:124,43:128,5:129,41:240,4:$Vg1,7:$Vh1,8:$Vi1,18:$VQ1,23:$Vj1,25:$Vk1,47:$Vl1,48:$Vm1,52:$Vn1,58:$Vo1}),o($VS1,[2,49]),o($VS1,[2,50]),o($Vp1,$V0,{49:3,17:4,50:5,19:7,3:12,54:13,79:22,5:32,6:33,101:144,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$V8,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,47:$Ve,48:$Vf,52:$Vg,53:$Vh,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:242,23:$V6,25:$V7,27:[1,241],31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($Vp1,$Vz,{17:46,26:[1,243],28:[1,244],35:[1,245],47:$Ve,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:247,23:$V6,25:$V7,27:[1,246],31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{11:[1,249],27:[1,248]},{27:[1,250]},o($VP,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:251,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:83,23:$V6,25:$V7,27:[1,252],31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,47:$V31,48:$V41,54:13,56:$V51,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:80,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,27:[1,253],39:$Vb,40:$VT,48:$V21},{3:254,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT},{27:[1,255]},{17:256,35:$VA,47:$Ve,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},{17:257,35:$VA,37:$VT1,47:$Ve,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,82:$VU1},o([21,22,24,35,37,40,46,47,57,58,61,62,63,64,65,66,67,68,69,70,71,78,81,82],$VV,{9:$VW,11:$VX,15:$VY,34:$VZ,55:$V_,56:$V$,72:$V01,96:$V11,102:[1,260]}),o([9,11,15,21,22,24,34,35,37,40,46,47,55,56,57,58,61,62,63,64,65,66,67,68,69,70,71,72,78,81,82,96,102],$Vb1,{38:[1,263],45:[1,262],103:[1,261]}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:264,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VV1,[2,198],{35:$VA,45:[1,266],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,82:[1,265]}),o($Vx,[2,63]),o($Vt,[2,172],{46:$Vw}),o([1,9,11,14,15,21,22,24,26,27,28,32,34,35,36,37,40,45,46,47,55,56,57,58,61,62,63,64,65,66,67,68,69,70,71,72,78,81,82,88,89,91,92,96,102,103,104],[2,71]),{9:$VW,11:$VX,15:$VY,35:[1,267]},o($VW1,[2,80],{35:$VA,58:$VC,63:$VF,64:$VG,68:$VK}),o($VA1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:268,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o([1,14,21,22,24,26,27,28,32,36,37,40,45,46,47,57,58,61,62,65,66,67,69,70,71,78,81,82,104],[2,102],{35:$VA,63:$VF,64:$VG,68:$VK}),o($VX1,[2,103],{35:$VA,57:$VB,58:$VC,61:$VD,63:$VF,64:$VG,65:$VH,67:$VJ,68:$VK,69:$VL}),o($VK1,[2,104],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL}),o($Vz1,[2,105],{35:$VA,64:$VG,68:$VK}),o($Vz1,[2,106],{35:$VA,64:$VG,68:$VK}),o($VW1,[2,107],{35:$VA,58:$VC,63:$VF,64:$VG,68:$VK}),o($VX1,[2,108],{35:$VA,57:$VB,58:$VC,61:$VD,63:$VF,64:$VG,65:$VH,67:$VJ,68:$VK,69:$VL}),o($VY1,[2,109],{35:$VA,57:$VB,58:$VC,63:$VF,64:$VG,65:$VH,67:$VJ,68:$VK}),o([1,14,21,22,24,26,27,28,32,36,37,40,45,46,47,57,58,61,62,63,64,65,66,67,69,70,71,78,81,82,104],[2,110],{35:$VA,68:$VK}),o($VY1,[2,111],{35:$VA,57:$VB,58:$VC,63:$VF,64:$VG,65:$VH,67:$VJ,68:$VK}),o($VK1,[2,112],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL}),o($VB1,[2,113],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN}),o($VB1,[2,119],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN}),{32:[1,269],46:$VZ1,47:$V_1},o([14,21,22,32,46,47],$V$1,{3:12,54:13,79:22,5:32,6:33,19:64,44:272,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($Vv1,[2,57],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VU,$VV,{9:$VW,11:$VX,15:$VY,34:$Vx1,56:$Vx1,55:$V_,72:$V01,96:$V11}),o($Vs1,$Vt1,{13:273,45:$Vu1}),{17:257,35:$VA,47:$Ve,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},o($VW1,[2,73],{35:$VA,58:$VC,63:$VF,64:$VG,68:$VK}),o($VU,[2,74]),o($VB1,[2,77],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN}),o($VA1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:274,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($VK1,[2,143],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL}),o($Vc1,[2,6]),o($Vc1,[2,7]),o($Vd1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,12:118,19:275,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,36:[1,276],39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($Ve1,$Vf1,{41:120,99:121,10:123,98:124,43:128,5:129,4:$Vg1,7:$Vh1,8:$Vi1,18:$VQ1,23:$Vj1,25:$Vk1,47:$Vl1,48:$Vm1,52:$Vn1,58:$Vo1}),o($V02,$Vt1,{13:277,45:$Vu1}),o($VB1,[2,78],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN}),o($VU,[2,84],{9:$VW,11:$VX,15:$VY}),o($VU,[2,86],{9:$VW,11:$VX,15:$VY}),{3:278,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT},o($Vz1,[2,95],{35:$VA,64:$VG,68:$VK}),o($VA1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:279,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($V12,$Vt1,{13:280,45:$Vu1}),o($VU,[2,87],{9:$VW,11:$VX,15:$VY}),{3:281,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT},o($Vz1,[2,96],{35:$VA,64:$VG,68:$VK}),o($VU,[2,88],{9:$VW,11:$VX,15:$VY}),{3:282,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT},o($Vz1,[2,97],{35:$VA,64:$VG,68:$VK}),o($V02,$Vt1,{13:283,45:$Vu1}),o($V02,$Vt1,{13:284,45:$Vu1}),o($VU,$VC1,{77:285,89:$VD1}),o($VU,[2,120]),{17:286,47:$Ve,76:[1,287]},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:288,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($V12,$Vt1,{13:289,45:$Vu1}),o($VF1,[2,128],{82:$VG1,88:[1,290],89:[1,291]}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:292,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{17:293,47:$Ve},{17:294,47:$Ve},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:105,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,86:295,90:$Vt,93:$Vu,97:$Vv},{17:296,45:$VE1,47:$Ve},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,17:297,18:$V5,19:64,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,44:298,47:$Ve,48:$VS,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{17:299,47:$Ve},{47:$VI1,95:300,104:$VJ1},{17:301,47:$Ve},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:105,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,86:302,90:$Vt,93:$Vu,97:$Vv},o($V81,[2,208],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($V12,$Vt1,{13:303,45:$Vu1}),o($V02,$Vt1,{13:304,45:$Vu1}),{21:[1,305],22:[1,306],40:$VL1,46:$V22,47:$V32,79:307,81:$Vp},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:310,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VV1,[2,202]),{3:147,4:$Vq1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:311,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,38:$Vr1,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{35:$VA,36:[1,312],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},{21:[1,313],35:$VA,37:[1,314],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},{21:[1,315],46:$VZ1,47:$V_1},o($VM1,$Vt1,{13:316,45:$Vu1}),{24:[1,317],46:$V42},o([22,24,46],$V$1,{10:123,98:124,43:128,5:129,99:319,4:$Vg1,7:$Vh1,8:$Vi1,18:$VQ1,23:$Vj1,25:$Vk1,48:$Vm1,52:$Vn1,58:$Vo1}),o($Vy,$Vt1,{13:320,45:$VO1}),o($Vd1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:321,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:322,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,47:[1,323],48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{4:$Vg1,7:$Vh1,43:324},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:325,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:326,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VP1,[2,160]),o($VP1,[2,161]),o($VP1,[2,162],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),{4:$Vg1,7:$Vh1,43:327},o($VN1,$Vt1,{13:328,45:$VO1}),o($Vc1,[2,14]),{27:[1,329],35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},{27:[1,330]},{27:[1,331]},{3:332,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT},o($Vc1,[2,17]),{27:[1,333],35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},o($Vc1,[2,20]),o($Vy1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:334,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($Vc1,[2,22]),o($Vs1,$Vt1,{13:335,45:$Vu1}),o($Vc1,[2,24]),o($Vc1,[2,25]),{9:$VW,11:$VX,15:$VY,35:[1,336]},o($VS1,[2,169]),o($Vc1,[2,41]),o($Vc1,[2,42]),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:337,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:338,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:339,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:340,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:341,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,39:$Vb,40:$VT},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:342,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{35:$VA,36:[1,343],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:344,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:345,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:346,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($V12,$Vt1,{13:347,45:$Vu1}),{51:$V52,73:$V62},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:64,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,44:350,48:$VS,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VA1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:351,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($Vv1,[2,53]),{32:[1,352],46:$VZ1,47:$V_1},o($V12,$Vt1,{13:353,45:$Vu1}),o($Vd1,$Vw1,{35:$VA,36:[1,354],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:355,21:[1,356],23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{14:[1,357],46:$VZ1,47:$V_1},o($VU,[2,89],{9:$VW,11:$VX,15:$VY}),o($V12,$Vt1,{13:358,45:$Vu1}),{22:[1,359],46:$VZ1,47:$V_1},o($VU,[2,90],{9:$VW,11:$VX,15:$VY}),o($VU,[2,91],{9:$VW,11:$VX,15:$VY}),{14:[1,360],46:$VZ1,47:$V_1},{14:[1,361],46:$VZ1,47:$V_1},o($VU,[2,118]),o($VU,[2,174]),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:362,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o([1,14,21,22,24,26,27,28,32,36,37,40,45,46,47,70,71,78,81,104],[2,121],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,82:[1,363]}),{22:[1,364],46:$VZ1,47:$V_1},{17:365,47:$Ve},{17:366,47:$Ve},o($VH1,[2,148],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VU,[2,132]),o($VU,[2,133]),{17:367,45:$VE1,47:$Ve},o($V72,[2,206]),o($VU,[2,136],{92:[1,368]}),{17:369,47:$Ve},o($VU,[2,140]),{17:370,47:$Ve},o($VU,[2,142]),{45:$VE1,47:[2,210]},{22:[1,371],46:$VZ1,47:$V_1},{14:[1,372],46:$VZ1,47:$V_1},o($Vc1,[2,11]),{21:[1,373]},o($VV1,[2,203]),{40:$VL1,79:374,81:$Vp},{40:$VL1,79:375,81:$Vp},{21:[1,376],35:$VA,37:[1,377],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},o($VV1,[2,180],{35:$VA,37:$VT1,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,82:$VU1}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:378,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($Vc1,[2,33]),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:379,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($Vc1,[2,43],{42:[1,380]}),{21:[1,381],46:$VZ1,47:$V_1},o($Vc1,[2,44],{42:[1,382]}),{4:$Vg1,5:129,7:$Vh1,8:$Vi1,10:123,18:$VQ1,23:$Vj1,25:$Vk1,43:128,48:$Vm1,52:$Vn1,58:$Vo1,98:124,99:383},o($VP1,[2,166]),{22:[1,384],46:$V42},o($VM1,$Vt1,{13:385,45:$Vu1}),o($VP1,[2,155],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VA1,$VQ,{3:12,54:13,79:22,5:32,6:33,44:63,19:64,12:386,4:$V1,7:$V2,8:$V3,16:$V4,18:$V5,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$VS,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv}),o($VR1,[2,151]),o($VP1,[2,158],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VP1,[2,159],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VR1,[2,152]),{24:[1,387],46:$V42},o($Vc1,[2,15]),o($Vc1,[2,16]),o($Vc1,[2,19]),{9:$VW,11:$VX,15:$VY,35:[1,388]},o($Vc1,[2,18]),o($V02,$Vt1,{13:389,45:$Vu1}),{32:[1,390],46:$VZ1,47:$V_1},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:392,23:$V6,25:$V7,27:[1,391],31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VV1,[2,181],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VV1,[2,182],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,82:[1,393]}),o($VV1,[2,176],{35:$VA,37:[1,395],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,82:[1,394]}),o($VV1,[2,184],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,82:[1,396]}),{9:$VW,11:$VX,15:$VY,103:[1,397]},{35:$VA,36:[1,398],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:399,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VV1,[2,199],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VV1,[2,200],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,82:[1,400]}),o($VU,[2,75]),{22:[1,401],46:$VZ1,47:$V_1},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:402,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{17:403,47:$Ve},o($Vv1,[2,54]),o($V12,$Vt1,{13:404,45:$Vu1}),{73:$V62},{22:[1,405],46:$VZ1,47:$V_1},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:406,21:[1,407],23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{21:[1,409],35:$VA,37:[1,408],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},o($Vc1,[2,40]),o($Vc1,[2,8]),{22:[1,410],46:$VZ1,47:$V_1},o($VU,[2,99]),{17:411,47:$Ve},{17:412,47:$Ve},{17:413,35:$VA,47:$Ve,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:414,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VU,[2,124]),o($VU,[2,129]),o($VU,[2,130]),o($V72,[2,207]),{17:415,47:$Ve},o($VU,[2,138],{92:[1,416]}),o($VU,[2,141]),o($VU,[2,146]),{17:417,47:$Ve},o($Vc1,[2,12]),o($VV1,[2,204]),o($VV1,[2,205]),o($Vc1,[2,29]),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:418,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{21:[1,419],35:$VA,37:[1,420],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},{21:[1,421],35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},o($Vc1,[2,45]),{20:422,40:$VL1,42:$V82,79:222,81:$Vp},o($Vc1,[2,46]),o($VP1,[2,167]),o($VP1,[2,168]),{21:[1,424],46:$VZ1,47:$V_1},o($V12,$Vt1,{13:425,45:$Vu1}),{42:[1,426]},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:346,23:$V6,25:$V7,27:[1,427],31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{14:[1,428],46:$VZ1,47:$V_1},{30:[1,429],51:$V52,73:$V62},o($Vc1,[2,26]),{27:[1,430],35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:431,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:432,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:433,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:434,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:435,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:436,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VV1,[2,189],{35:$VA,37:[1,438],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,82:[1,437]}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:439,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VU,[2,81]),o($Vx,[2,67],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VU,[2,115]),{22:[1,440],46:$VZ1,47:$V_1},o($VU,[2,79]),{21:[1,442],35:$VA,37:[1,441],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},o($Vc1,[2,38]),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:443,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($Vc1,[2,39]),o($VU,[2,98]),o($VU,[2,116]),o($VU,[2,117]),o($VU,$VC1,{77:444,89:$VD1}),o($VK1,[2,122],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL}),o($VU,[2,137]),{17:445,47:$Ve},o($Vc1,[2,10]),{21:[1,446],35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},o($Vc1,[2,31]),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:447,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($Vc1,[2,34]),{24:[1,448],40:$VL1,46:$V22,47:$V32,79:307,81:$Vp},o($VR1,[2,154]),{42:$V82},{22:[1,449],46:$VZ1,47:$V_1},o($VR1,[2,153]),o($Vc1,[2,27]),{27:[1,450]},{27:[1,451]},o($Vc1,[2,28]),o($VV1,[2,183],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VV1,[2,177],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VV1,[2,178],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,82:[1,452]}),o($VV1,[2,185],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VV1,[2,186],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,82:[1,453]}),o($VV1,[2,188],{35:$VA,37:[1,455],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,82:[1,454]}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:456,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:457,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VV1,[2,201],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($Vv1,[2,55]),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:458,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($Vc1,[2,37]),{21:[1,459],35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},o($VU,[2,175]),o($VU,[2,139]),o($Vc1,[2,30]),{21:[1,460],35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},o($Vc1,[2,13]),o($VP1,[2,156]),o($Vc1,[2,21]),o($Vc1,[2,23]),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:461,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:462,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:463,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:464,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VV1,[2,191],{35:$VA,37:[1,465],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VV1,[2,193],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,82:[1,466]}),{21:[1,467],35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO},o($Vc1,[2,36]),o($Vc1,[2,32]),o($VV1,[2,179],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VV1,[2,187],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VV1,[2,190],{35:$VA,37:[1,468],57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VV1,[2,192],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO,82:[1,469]}),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:470,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:471,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($Vc1,[2,35]),{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:472,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},{3:12,4:$V1,5:32,6:33,7:$V2,8:$V3,16:$V4,18:$V5,19:473,23:$V6,25:$V7,31:$VR,33:$V9,34:$Va,39:$Vb,40:$Vc,42:$Vd,48:$V61,54:13,58:$Vi,59:$Vj,60:$Vk,74:$Vl,75:$Vm,76:$Vn,79:22,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv},o($VV1,[2,197],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VV1,[2,195],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VV1,[2,196],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO}),o($VV1,[2,194],{35:$VA,57:$VB,58:$VC,61:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,78:$VO})],\ndefaultActions: {2:[2,212]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        function _parseError (msg, hash) {\n            this.message = msg;\n            this.hash = hash;\n        }\n        _parseError.prototype = Error;\n\n        throw new _parseError(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}\n","/home/travis/build/npmtest/node-npmtest-livescript/node_modules/livescript/lib/ast.js":"// Generated by LiveScript 1.5.0\nvar fold, ref$, nameFromPath, stripString, SourceNode, SourceMapGenerator, sn, snEmpty, snSafe, snRemoveLeft, snAutofill, Node, Negatable, Block, Atom, Literal, Var, Key, Index, Slice, Chain, Call, List, Obj, Prop, Arr, Yield, Unary, Binary, Assign, Import, In, Existence, Fun, Class, Super, Parens, Splat, Jump, Throw, Return, While, For, StepSlice, Try, Switch, Case, If, Label, Cascade, JS, Require, Util, Vars, CopyL, DECLS, UTILS, LEVEL_TOP, LEVEL_PAREN, LEVEL_LIST, LEVEL_COND, LEVEL_OP, LEVEL_CALL, PREC, TAB, ID, SIMPLENUM, slice$ = [].slice, toString$ = {}.toString;\nfold = require('prelude-ls').fold;\nref$ = require('./util'), nameFromPath = ref$.nameFromPath, stripString = ref$.stripString;\nref$ = require('source-map'), SourceNode = ref$.SourceNode, SourceMapGenerator = ref$.SourceMapGenerator;\nsn = function(node){\n  var parts, res$, i$, to$, result, e;\n  node == null && (node = {});\n  res$ = [];\n  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {\n    res$.push(arguments[i$]);\n  }\n  parts = res$;\n  try {\n    result = new SourceNode(node.line, node.column, null, parts);\n    result.displayName = node.constructor.displayName;\n    return result;\n  } catch (e$) {\n    e = e$;\n    console.dir(parts);\n    throw e;\n  }\n};\nsnEmpty = function(node){\n  var i$, ref$, len$, child;\n  if (node instanceof SourceNode) {\n    for (i$ = 0, len$ = (ref$ = node.children).length; i$ < len$; ++i$) {\n      child = ref$[i$];\n      if (!snEmpty(child)) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    return !node;\n  }\n};\nsnSafe = function(code){\n  if (code instanceof SourceNode) {\n    return code;\n  } else {\n    return code.toString();\n  }\n};\nsnRemoveLeft = function(node, count){\n  var i$, to$, i, child;\n  for (i$ = 0, to$ = node.children.length; i$ < to$; ++i$) {\n    i = i$;\n    child = node.children[i];\n    if (child instanceof SourceNode) {\n      count = snRemoveLeft(child, count);\n    } else {\n      child = child.toString();\n      node.children[i] = child.slice(count);\n      count -= child.length;\n    }\n    if (count <= 0) {\n      return 0;\n    }\n  }\n  return count;\n};\nsnAutofill = function(node, parents){\n  var i$, len$, p, ref$, child;\n  parents == null && (parents = []);\n  if (node instanceof SourceNode) {\n    if (node.line) {\n      for (i$ = 0, len$ = parents.length; i$ < len$; ++i$) {\n        p = parents[i$];\n        p.line = node.line;\n        p.column = node.column;\n      }\n      parents.length = 0;\n    } else {\n      parents.push(node);\n    }\n    for (i$ = 0, len$ = (ref$ = node.children).length; i$ < len$; ++i$) {\n      child = ref$[i$];\n      snAutofill(child, parents);\n    }\n  }\n  return node;\n};\nSourceNode.prototype.replace = function(){\n  var args, res$, i$, to$;\n  res$ = [];\n  for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {\n    res$.push(arguments[i$]);\n  }\n  args = res$;\n  return new SourceNode(this.line, this.column, this.source, (function(){\n    var i$, x$, ref$, len$, results$ = [];\n    for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {\n      x$ = ref$[i$];\n      results$.push(x$.replace.apply(x$, args));\n    }\n    return results$;\n  }.call(this)), this.name);\n};\nSourceNode.prototype.setFile = function(filename){\n  var i$, ref$, len$, child, results$ = [];\n  this.source = filename;\n  for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {\n    child = ref$[i$];\n    if (child instanceof SourceNode) {\n      results$.push(child.setFile(filename));\n    }\n  }\n  return results$;\n};\nSourceNode.prototype.toStringWithSourceMap = function(){\n  var args, res$, i$, to$, gen, genLine, genColumn, stack, code, debugOutput, debugIndent, debugIndentStr, genForNode;\n  res$ = [];\n  for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {\n    res$.push(arguments[i$]);\n  }\n  args = res$;\n  gen = (function(func, args, ctor) {\n    ctor.prototype = func.prototype;\n    var child = new ctor, result = func.apply(child, args), t;\n    return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n  })(SourceMapGenerator, args, function(){});\n  genLine = 1;\n  genColumn = 0;\n  stack = [];\n  code = '';\n  debugOutput = '';\n  debugIndent = '';\n  debugIndentStr = '  ';\n  genForNode = function(node){\n    var valid, i$, ref$, len$, child, cur, to$, i, c, results$ = [];\n    if (node instanceof SourceNode) {\n      debugOutput += debugIndent + node.displayName;\n      valid = node.line && 'column' in node;\n      if (valid) {\n        stack.push(node);\n        debugOutput += '!';\n      }\n      debugOutput += \" \" + node.line + \":\" + node.column + \" \" + genLine + \":\" + genColumn + \"\\n\";\n      debugIndent += debugIndentStr;\n      for (i$ = 0, len$ = (ref$ = node.children).length; i$ < len$; ++i$) {\n        child = ref$[i$];\n        genForNode(child);\n      }\n      debugIndent = debugIndent.slice(0, debugIndent.length - debugIndentStr.length);\n      if (valid) {\n        return stack.pop();\n      }\n    } else {\n      debugOutput += debugIndent + \"\" + JSON.stringify(node) + \"\\n\";\n      code += node;\n      cur = stack[stack.length - 1];\n      if (cur) {\n        gen.addMapping({\n          source: cur.source,\n          original: {\n            line: cur.line,\n            column: cur.column\n          },\n          generated: {\n            line: genLine,\n            column: genColumn\n          },\n          name: cur.name\n        });\n      }\n      for (i$ = 0, to$ = node.length; i$ < to$; ++i$) {\n        i = i$;\n        c = node.charAt(i);\n        if (c === \"\\n\") {\n          genColumn = 0;\n          ++genLine;\n          if (cur) {\n            results$.push(gen.addMapping({\n              source: cur.source,\n              original: {\n                line: cur.line,\n                column: cur.column\n              },\n              generated: {\n                line: genLine,\n                column: genColumn\n              },\n              name: cur.name\n            }));\n          }\n        } else {\n          results$.push(++genColumn);\n        }\n      }\n      return results$;\n    }\n  };\n  genForNode(this);\n  return {\n    code: code,\n    map: gen,\n    debug: debugOutput\n  };\n};\n/* # Use this to track down places where a SourceNode is being converted into a string and causing the location to be lost\ntmp-to-string = SourceNode::to-string\nSourceNode::to-string = (...args) ->\n    console.log(\"toString(): \", new Error().stack)\n    tmp-to-string.apply this, args\n*/\n(Node = function(){\n  throw Error('unimplemented');\n}).prototype = {\n  compile: function(options, level){\n    var o, node, code, that, i$, len$, tmp;\n    o = import$({}, options);\n    if (level != null) {\n      o.level = level;\n    }\n    node = this.unfoldSoak(o) || this;\n    if (o.level && node.isStatement()) {\n      return node.compileClosure(o);\n    }\n    code = (node.tab = o.indent, node).compileNode(o);\n    if (that = node.temps) {\n      for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {\n        tmp = that[i$];\n        o.scope.free(tmp);\n      }\n    }\n    return code;\n  },\n  compileClosure: function(o){\n    var that, fun, call, hasArgs, hasThis, out;\n    if (that = this.getJump()) {\n      that.carp('inconvertible statement');\n    }\n    fun = Fun([], Block(this));\n    call = Call();\n    if (o.inGenerator) {\n      fun.generator = true;\n    }\n    this.traverseChildren(function(it){\n      switch (it.value) {\n      case 'this':\n        hasThis = true;\n        break;\n      case 'arguments':\n        hasArgs = it.value = 'args$';\n      }\n    });\n    if (hasThis) {\n      call.args.push(Literal('this'));\n      call.method = '.call';\n    }\n    if (hasArgs) {\n      call.args.push(Literal('arguments'));\n      fun.params.push(Var('args$'));\n    }\n    out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);\n    if (o.inGenerator) {\n      out = new Yield('yieldfrom', out);\n    }\n    return out.compile(o);\n  },\n  compileBlock: function(o, node){\n    var code;\n    if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {\n      return sn(null, \"{\\n\", code, \"\\n\" + this.tab + \"}\");\n    } else {\n      return sn(node, '{}');\n    }\n  },\n  compileSpreadOver: function(o, list, transform){\n    var ob, them, i$, len$, i, node, sp, lat, ref$;\n    ob = list instanceof Obj;\n    them = list.items;\n    for (i$ = 0, len$ = them.length; i$ < len$; ++i$) {\n      i = i$;\n      node = them[i$];\n      if (sp = node instanceof Splat) {\n        node = node.it;\n      }\n      if (ob && !sp) {\n        node = node.val;\n      }\n      node = transform(node);\n      if (sp) {\n        node = lat = Splat(node);\n      }\n      if (ob && !sp) {\n        them[i].val = node;\n      } else {\n        them[i] = node;\n      }\n    }\n    if (!lat && (this['void'] || !o.level)) {\n      list = (ref$ = Block(ob ? (function(){\n        var i$, x$, ref$, len$, results$ = [];\n        for (i$ = 0, len$ = (ref$ = them).length; i$ < len$; ++i$) {\n          x$ = ref$[i$];\n          results$.push(x$.val);\n        }\n        return results$;\n      }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);\n    }\n    return list.compile(o, LEVEL_PAREN);\n  },\n  cache: function(o, once, level){\n    var ref$, sub, ref;\n    if (!this.isComplex()) {\n      return [ref$ = level != null ? this.compile(o, level) : this, ref$];\n    }\n    sub = Assign(ref = Var(o.scope.temporary()), this);\n    if (level != null) {\n      sub = sub.compile(o, level);\n      if (once) {\n        o.scope.free(ref.value);\n      }\n      return [sub, ref.value];\n    }\n    if (once) {\n      return [sub, (ref.temp = true, ref)];\n    } else {\n      return [sub, ref, [ref.value]];\n    }\n  },\n  compileLoopReference: function(o, name, ret, safeAccess){\n    var ref$, code, asn, tmp;\n    if (this instanceof Var && o.scope.check(this.value) || this instanceof Unary && ((ref$ = this.op) === '+' || ref$ === '-') && (-1 / 0 < (ref$ = +this.it.value) && ref$ < 1 / 0) || this instanceof Literal && !this.isComplex()) {\n      code = this.compile(o, LEVEL_PAREN);\n      if (safeAccess && !(this instanceof Var)) {\n        code = \"(\" + code + \")\";\n      }\n      return [code, code];\n    }\n    asn = Assign(Var(tmp = o.scope.temporary(name)), this);\n    ret || (asn['void'] = true);\n    return [tmp, asn.compile(o, ret ? LEVEL_CALL : LEVEL_PAREN)];\n  },\n  eachChild: function(fn){\n    var i$, ref$, len$, name, child, j$, len1$, i, node, that;\n    for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {\n      name = ref$[i$];\n      if (child = this[name]) {\n        if ('length' in child) {\n          for (j$ = 0, len1$ = child.length; j$ < len1$; ++j$) {\n            i = j$;\n            node = child[j$];\n            if (that = fn(node, name, i)) {\n              return that;\n            }\n          }\n        } else {\n          if ((that = fn(child, name)) != null) {\n            return that;\n          }\n        }\n      }\n    }\n  },\n  traverseChildren: function(fn, xscope){\n    var this$ = this;\n    return this.eachChild(function(node, name, index){\n      var ref$;\n      return (ref$ = fn(node, this$, name, index)) != null\n        ? ref$\n        : node.traverseChildren(fn, xscope);\n    });\n  },\n  anaphorize: function(){\n    var base, name, ref$;\n    this.children = this.aTargets;\n    if (this.eachChild(hasThat)) {\n      if ((base = this)[name = this.aSource] instanceof Existence) {\n        base = base[name];\n        name = 'it';\n      }\n      if (base[name].value !== 'that') {\n        base[name] = Assign(Var('that'), base[name]);\n      }\n    }\n    function hasThat(it){\n      var that;\n      return it.value === 'that' || ((that = it.aSource)\n        ? (that = it[that]) ? hasThat(that) : void 8\n        : it.eachChild(hasThat));\n    }\n    delete this.children;\n    return ref$ = this[this.aSource], ref$.cond = true, ref$;\n  },\n  carp: function(msg, type){\n    type == null && (type = SyntaxError);\n    throw type(msg + \" on line \" + (this.line || this.traverseChildren(function(it){\n      return it.line;\n    })));\n  },\n  delegate: function(names, fn){\n    var i$, len$;\n    for (i$ = 0, len$ = names.length; i$ < len$; ++i$) {\n      (fn$.call(this, names[i$]));\n    }\n    function fn$(name){\n      this[name] = function(it){\n        return fn.call(this, name, it);\n      };\n    }\n  },\n  children: [],\n  terminator: ';',\n  isComplex: YES,\n  isStatement: NO,\n  isAssignable: NO,\n  isCallable: NO,\n  isEmpty: NO,\n  isArray: NO,\n  isString: NO,\n  isRegex: NO,\n  isMatcher: function(){\n    return this.isString() || this.isRegex();\n  },\n  assigns: NO,\n  ripName: VOID,\n  unfoldSoak: VOID,\n  unfoldAssign: VOID,\n  unparen: THIS,\n  unwrap: THIS,\n  maybeKey: THIS,\n  expandSlice: THIS,\n  varName: String,\n  getAccessors: VOID,\n  getCall: VOID,\n  getDefault: VOID,\n  getJump: VOID,\n  invert: function(){\n    return Unary('!', this, true);\n  },\n  invertCheck: function(it){\n    if (it.inverted) {\n      return this.invert();\n    } else {\n      return this;\n    }\n  },\n  addElse: function($else){\n    this['else'] = $else;\n    return this;\n  },\n  makeReturn: function(ref, obj){\n    var items, kv, i, v;\n    if (obj) {\n      items = this instanceof Arr\n        ? (this.items[0] == null || this.items[1] == null && this.carp('must specify both key and value for object comprehension'), this.items)\n        : (kv = 'keyValue$', (function(){\n          var i$, ref$, len$, results$ = [];\n          for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ < len$; ++i$) {\n            i = i$;\n            v = ref$[i$];\n            results$.push(Chain(v).add(Index(Literal(i))));\n          }\n          return results$;\n        }.call(this)));\n      return Assign(Chain(Var(ref)).add(Index(items[0], '.', true)), items[1]);\n    } else if (ref) {\n      return Call.make(JS(ref + '.push'), [this]);\n    } else {\n      return Return(this);\n    }\n  },\n  show: String,\n  toString: function(idt){\n    var tree, that;\n    idt || (idt = '');\n    tree = '\\n' + idt + this.constructor.displayName;\n    if (that = this.show()) {\n      tree += ' ' + that;\n    }\n    this.eachChild(function(it){\n      tree += it.toString(idt + TAB);\n    });\n    return tree;\n  },\n  stringify: function(space){\n    return JSON.stringify(this, null, space);\n  },\n  toJSON: function(){\n    return import$({\n      type: this.constructor.displayName\n    }, this);\n  }\n};\nexports.parse = function(json){\n  return exports.fromJSON(JSON.parse(json));\n};\nexports.fromJSON = (function(){\n  function fromJSON(it){\n    var that, node, key, val, i$, len$, v, results$ = [];\n    if (!(it && typeof it === 'object')) {\n      return it;\n    }\n    if (that = it.type) {\n      node = clone$(exports[that].prototype);\n      for (key in it) {\n        val = it[key];\n        node[key] = fromJSON(val);\n      }\n      return node;\n    }\n    if (it.length != null) {\n      for (i$ = 0, len$ = it.length; i$ < len$; ++i$) {\n        v = it[i$];\n        results$.push(fromJSON(v));\n      }\n      return results$;\n    } else {\n      return it;\n    }\n  }\n  return fromJSON;\n}());\nNegatable = {\n  show: function(){\n    return this.negated && '!';\n  },\n  invert: function(){\n    this.negated = !this.negated;\n    return this;\n  }\n};\nexports.Block = Block = (function(superclass){\n  var prototype = extend$((import$(Block, superclass).displayName = 'Block', Block), superclass).prototype, constructor = Block;\n  function Block(body){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    body || (body = []);\n    if ('length' in body) {\n      this$.lines = body;\n    } else {\n      this$.lines = [];\n      this$.add(body);\n    }\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Block.prototype.children = ['lines'];\n  Block.prototype.toJSON = function(){\n    delete this.back;\n    return superclass.prototype.toJSON.call(this);\n  };\n  Block.prototype.add = function(it){\n    var that, ref$;\n    it = it.unparen();\n    switch (false) {\n    case !(that = this.back):\n      that.add(it);\n      break;\n    case !(that = it.lines):\n      (ref$ = this.lines).push.apply(ref$, that);\n      break;\n    default:\n      this.lines.push(it);\n      if (that = (ref$ = it.back, delete it.back, ref$)) {\n        this.back = that;\n      }\n    }\n    return this;\n  };\n  Block.prototype.prepend = function(){\n    var ref$;\n    (ref$ = this.lines).splice.apply(ref$, [this.neck(), 0].concat(slice$.call(arguments)));\n    return this;\n  };\n  Block.prototype.pipe = function(target, type){\n    var args;\n    args = type === '|>' ? this.lines.pop() : target;\n    if (toString$.call(args).slice(8, -1) !== 'Array') {\n      args = [args];\n    }\n    switch (type) {\n    case '|>':\n      this.lines.push(Call.make(target, args, {\n        pipe: true\n      }));\n      break;\n    case '<|':\n      this.lines.push(Call.make(this.lines.pop(), args));\n    }\n    return this;\n  };\n  Block.prototype.unwrap = function(){\n    if (this.lines.length === 1) {\n      return this.lines[0];\n    } else {\n      return this;\n    }\n  };\n  Block.prototype.chomp = function(){\n    var lines, i, that;\n    lines = this.lines;\n    i = lines.length;\n    while (that = lines[--i]) {\n      if (!that.comment) {\n        break;\n      }\n    }\n    lines.length = i + 1;\n    return this;\n  };\n  Block.prototype.neck = function(){\n    var pos, i$, ref$, len$, x;\n    pos = 0;\n    for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {\n      x = ref$[i$];\n      if (!(x.comment || x instanceof Literal)) {\n        break;\n      }\n      ++pos;\n    }\n    return pos;\n  };\n  Block.prototype.isComplex = function(){\n    var ref$;\n    return this.lines.length > 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);\n  };\n  prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], function(it){\n    var ref$, ref1$;\n    return (ref$ = (ref1$ = this.lines)[ref1$.length - 1]) != null ? ref$[it]() : void 8;\n  });\n  Block.prototype.getJump = function(it){\n    var i$, ref$, len$, node, that;\n    for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {\n      node = ref$[i$];\n      if (that = node.getJump(it)) {\n        return that;\n      }\n    }\n  };\n  Block.prototype.makeReturn = function(){\n    var that, ref$, key$, ref1$;\n    this.chomp();\n    if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref$, arguments) : void 8) {\n      if (that instanceof Return && !that.it) {\n        --this.lines.length;\n      }\n    }\n    return this;\n  };\n  Block.prototype.compile = function(o, level){\n    var tab, codes, i$, ref$, len$, node, code;\n    level == null && (level = o.level);\n    if (level) {\n      return this.compileExpressions(o, level);\n    }\n    o.block = this;\n    tab = o.indent;\n    codes = [];\n    for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {\n      node = ref$[i$];\n      node = node.unfoldSoak(o) || node;\n      if (snEmpty(code = (node.front = true, node).compile(o, level))) {\n        continue;\n      }\n      codes.push(tab);\n      codes.push(code);\n      node.isStatement() || codes.push(node.terminator);\n      codes.push('\\n');\n    }\n    codes.pop();\n    return sn.apply(null, [null].concat(slice$.call(codes)));\n  };\n  Block.prototype.compileRoot = function(options){\n    var o, that, ref$, bare, prefix, ref1$, code, result;\n    o = (import$({\n      level: LEVEL_TOP,\n      scope: this.scope = Scope.root = new Scope\n    }, options));\n    if (that = (ref$ = o.saveScope, delete o.saveScope, ref$)) {\n      this.scope = Scope.root = o.scope = that.savedScope || (that.savedScope = o.scope);\n    }\n    delete o.filename;\n    o.indent = (bare = (ref$ = o.bare, delete o.bare, ref$)) ? '' : TAB;\n    if (/^\\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {\n      prefix = this.lines.shift().code + '\\n';\n    }\n    if ((ref1$ = o.eval, delete o.eval, ref1$) && this.chomp().lines.length) {\n      if (bare) {\n        this.lines.push(Parens(this.lines.pop()));\n      } else {\n        this.makeReturn();\n      }\n    }\n    code = [this.compileWithDeclarations(o)];\n    bare || (code = [\"(function(){\\n\"].concat(slice$.call(code), [\"\\n}).call(this);\\n\"]));\n    return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));\n  };\n  Block.prototype.compileWithDeclarations = function(o){\n    var pre, i, rest, post, that;\n    o.level = LEVEL_TOP;\n    pre = [];\n    if (i = this.neck()) {\n      rest = this.lines.splice(i, 9e9);\n      pre = [this.compile(o), \"\\n\"];\n      this.lines = rest;\n    }\n    if (snEmpty(post = this.compile(o))) {\n      return sn(this, pre[0] || []);\n    }\n    return sn.apply(null, [null].concat(slice$.call(pre), [(that = this.scope) ? that.emit(post, o.indent) : post]));\n  };\n  Block.prototype.compileExpressions = function(o, level){\n    var lines, i, that, code, last, i$, len$, node;\n    lines = this.chomp().lines;\n    i = -1;\n    while (that = lines[++i]) {\n      if (that.comment) {\n        lines.splice(i--, 1);\n      }\n    }\n    if (!lines.length) {\n      lines.push(Literal('void'));\n    }\n    lines[0].front = this.front;\n    lines[lines.length - 1]['void'] = this['void'];\n    if (!lines[1]) {\n      return lines[0].compile(o, level);\n    }\n    code = [];\n    last = lines.pop();\n    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {\n      node = lines[i$];\n      code.push((node['void'] = true, node).compile(o, LEVEL_PAREN), ', ');\n    }\n    code.push(last.compile(o, LEVEL_PAREN));\n    if (level < LEVEL_LIST) {\n      return sn.apply(null, [null].concat(slice$.call(code)));\n    } else {\n      return sn.apply(null, [null, \"(\"].concat(slice$.call(code), [\")\"]));\n    }\n  };\n  return Block;\n}(Node));\nAtom = (function(superclass){\n  var prototype = extend$((import$(Atom, superclass).displayName = 'Atom', Atom), superclass).prototype, constructor = Atom;\n  Atom.prototype.show = function(){\n    return this.value;\n  };\n  Atom.prototype.isComplex = NO;\n  function Atom(){\n    Atom.superclass.apply(this, arguments);\n  }\n  return Atom;\n}(Node));\nexports.Literal = Literal = (function(superclass){\n  var prototype = extend$((import$(Literal, superclass).displayName = 'Literal', Literal), superclass).prototype, constructor = Literal;\n  function Literal(value){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.value = value;\n    if (value.js) {\n      return JS(value + \"\", true);\n    }\n    if (value === 'super') {\n      return new Super;\n    }\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Literal.prototype.isEmpty = function(){\n    var ref$;\n    return (ref$ = this.value) === 'void' || ref$ === 'null';\n  };\n  Literal.prototype.isCallable = function(){\n    var ref$;\n    return (ref$ = this.value) === 'this' || ref$ === 'eval' || ref$ === '..';\n  };\n  Literal.prototype.isString = function(){\n    return 0 <= '\\'\"'.indexOf((this.value + \"\").charAt());\n  };\n  Literal.prototype.isRegex = function(){\n    return (this.value + \"\").charAt() === '/';\n  };\n  Literal.prototype.isComplex = function(){\n    return this.isRegex() || this.value === 'debugger';\n  };\n  Literal.prototype.isWhat = function(){\n    switch (false) {\n    case !this.isEmpty():\n      return 'empty';\n    case !this.isCallable():\n      return 'callable';\n    case !this.isString():\n      return 'string';\n    case !this.isRegex():\n      return 'regex';\n    case !this.isComplex():\n      return 'complex';\n    default:\n\n    }\n  };\n  Literal.prototype.varName = function(){\n    if (/^\\w+$/.test(this.value)) {\n      return '$' + this.value;\n    } else {\n      return '';\n    }\n  };\n  Literal.prototype.makeReturn = function(it){\n    if (!it && this.value === 'debugger') {\n      return this;\n    } else {\n      return superclass.prototype.makeReturn.apply(this, arguments);\n    }\n  };\n  Literal.prototype.maybeKey = function(){\n    if (ID.test(this.value)) {\n      return Key(this.value);\n    } else {\n      return this;\n    }\n  };\n  Literal.prototype.compile = function(o, level){\n    var val, ref$;\n    level == null && (level = o.level);\n    switch (val = this.value + \"\") {\n    case 'this':\n      return sn(this, ((ref$ = o.scope.fun) != null ? ref$.bound : void 8) || val);\n    case 'void':\n      if (!level) {\n        return sn(this, '');\n      }\n      val += ' 8';\n      // fallthrough\n    case 'null':\n      if (level === LEVEL_CALL) {\n        this.carp('invalid use of ' + this.value);\n      }\n      break;\n    case 'on':\n    case 'yes':\n      val = 'true';\n      break;\n    case 'off':\n    case 'no':\n      val = 'false';\n      break;\n    case '*':\n      this.carp('stray star');\n      break;\n    case '..':\n      if (!(val = o.ref)) {\n        this.carp('stray reference');\n      }\n      this.cascadee || (val.erred = true);\n      break;\n    case 'debugger':\n      if (level) {\n        return sn(this, \"(function(){ debugger; }())\");\n      }\n    }\n    return sn(this, snSafe(val));\n  };\n  return Literal;\n}(Atom));\nexports.Var = Var = (function(superclass){\n  var prototype = extend$((import$(Var, superclass).displayName = 'Var', Var), superclass).prototype, constructor = Var;\n  function Var(value){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.value = value;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  prototype.isAssignable = prototype.isCallable = YES;\n  Var.prototype.assigns = function(it){\n    return it === this.value;\n  };\n  Var.prototype.maybeKey = function(){\n    var ref$;\n    return ref$ = Key(this.value), ref$.line = this.line, ref$;\n  };\n  Var.prototype.varName = prototype.show;\n  Var.prototype.compile = function(o){\n    return sn(this, this.temp\n      ? o.scope.free(this.value)\n      : this.value);\n  };\n  return Var;\n}(Atom));\nexports.Key = Key = (function(superclass){\n  var prototype = extend$((import$(Key, superclass).displayName = 'Key', Key), superclass).prototype, constructor = Key;\n  function Key(name, reserved){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.reserved = reserved || name.reserved;\n    this$.name = '' + name;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Key.prototype.isComplex = NO;\n  Key.prototype.assigns = function(it){\n    return it === this.name;\n  };\n  Key.prototype.varName = function(){\n    var name;\n    name = this.name;\n    if (this.reserved || (name === 'arguments' || name === 'eval')) {\n      return \"$\" + name;\n    } else {\n      return name;\n    }\n  };\n  Key.prototype.show = function(){\n    if (this.reserved) {\n      return \"'\" + this.name + \"'\";\n    } else {\n      return this.name;\n    }\n  };\n  Key.prototype.compile = function(){\n    return sn(this, this.show());\n  };\n  return Key;\n}(Node));\nexports.Index = Index = (function(superclass){\n  var prototype = extend$((import$(Index, superclass).displayName = 'Index', Index), superclass).prototype, constructor = Index;\n  function Index(key, symbol, init){\n    var k, this$ = this instanceof ctor$ ? this : new ctor$;\n    symbol || (symbol = '.');\n    if (init && key instanceof Arr) {\n      switch (key.items.length) {\n      case 1:\n        if (!((k = key.items[0]) instanceof Splat)) {\n          key = Parens(k);\n        }\n      }\n    }\n    switch (symbol) {\n    case '[]':\n      this$.vivify = Arr;\n      break;\n    case '{}':\n      this$.vivify = Obj;\n      break;\n    default:\n      if ('=' === symbol.slice(-1)) {\n        this$.assign = symbol.slice(1);\n      }\n    }\n    this$.key = key;\n    this$.symbol = symbol;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Index.prototype.children = ['key'];\n  Index.prototype.show = function(){\n    return [this.soak ? '?' : void 8] + this.symbol;\n  };\n  Index.prototype.isComplex = function(){\n    return this.key.isComplex();\n  };\n  Index.prototype.varName = function(){\n    var ref$;\n    return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) && this.key.varName();\n  };\n  Index.prototype.compile = function(o){\n    var code;\n    code = this.key.compile(o, LEVEL_PAREN);\n    if (this.key instanceof Key && '\\'' !== code.toString().charAt(0)) {\n      return sn(this, \".\", code);\n    } else {\n      return sn(this, \"[\", code, \"]\");\n    }\n  };\n  return Index;\n}(Node));\nexports.Slice = Slice = (function(superclass){\n  var prototype = extend$((import$(Slice, superclass).displayName = 'Slice', Slice), superclass).prototype, constructor = Slice;\n  function Slice(arg$){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;\n    this$.from == null && (this$.from = Literal(0));\n    if (this$.to && this$.type === 'to') {\n      this$.to = Binary('+', this$.to, Literal('1'));\n    }\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Slice.prototype.children = ['target', 'from', 'to'];\n  Slice.prototype.show = function(){\n    return this.type;\n  };\n  Slice.prototype.compileNode = function(o){\n    var args;\n    if (this.to && this.type === 'to') {\n      this.to = Binary('||', this.to, Literal('9e9'));\n    }\n    args = [this.target, this.from];\n    if (this.to) {\n      args.push(this.to);\n    }\n    return Chain(Var(util('slice'))).add(Index(Key('call'), '.', true)).add(Call(args)).compile(o);\n  };\n  return Slice;\n}(Node));\nexports.Chain = Chain = (function(superclass){\n  var prototype = extend$((import$(Chain, superclass).displayName = 'Chain', Chain), superclass).prototype, constructor = Chain;\n  function Chain(head, tails){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    if (!tails && head instanceof Chain) {\n      return head;\n    }\n    this$.head = head;\n    this$.tails = tails || [];\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Chain.prototype.children = ['head', 'tails'];\n  Chain.prototype.add = function(it){\n    var last, ref$, index, ref1$, bi, logics, call, f;\n    if (this.tails.length) {\n      last = (ref$ = this.tails)[ref$.length - 1];\n      if (last instanceof Call && ((ref$ = last.partialized) != null ? ref$.length : void 8) === 1 && it.args.length === 1) {\n        index = last.partialized[0].head.value;\n        delete last.partialized;\n        last.args[index] = it.args[0];\n        return this;\n      }\n    }\n    if (this.head instanceof Existence) {\n      ref1$ = Chain(this.head.it), this.head = ref1$.head, this.tails = ref1$.tails;\n      it.soak = true;\n    }\n    this.tails.push(it);\n    bi = this.head instanceof Parens && this.head.it instanceof Binary && !this.head.it.partial\n      ? this.head.it\n      : this.head instanceof Binary && !this.head.partial ? this.head : void 8;\n    if (this.head instanceof Super) {\n      if (!this.head.called && it instanceof Call && !it.method) {\n        it.method = '.call';\n        it.args.unshift(Literal('this'));\n        this.head.called = true;\n      } else if (!this.tails[1] && ((ref1$ = it.key) != null ? ref1$.name : void 8) === 'prototype') {\n        this.head.sproto = true;\n      }\n    } else if (it instanceof Call && this.tails.length === 1 && bi && in$(bi.op, logics = ['&&', '||', 'xor'])) {\n      call = it;\n      f = function(x, key){\n        var y;\n        y = x[key];\n        if (y instanceof Binary && in$(y.op, logics)) {\n          f(y, 'first');\n          return f(y, 'second');\n        } else {\n          return x[key] = Chain(y).autoCompare(call.args);\n        }\n      };\n      f(bi, 'first');\n      f(bi, 'second');\n      return bi;\n    }\n    return this;\n  };\n  Chain.prototype.autoCompare = function(target){\n    var test;\n    test = this.head;\n    switch (false) {\n    case !(test instanceof Literal):\n      return Binary('===', test, target[0]);\n    case !(test instanceof Unary && test.it instanceof Literal):\n      return Binary('===', test, target[0]);\n    case !(test instanceof Arr || test instanceof Obj):\n      return Binary('====', test, target[0]);\n    case !(test instanceof Var && test.value === '_'):\n      return Literal('true');\n    default:\n      return this.add(Call(target)) || [];\n    }\n  };\n  Chain.prototype.flipIt = function(){\n    this.flip = true;\n    return this;\n  };\n  Chain.prototype.unwrap = function(){\n    if (this.tails.length) {\n      return this;\n    } else {\n      return this.head;\n    }\n  };\n  prototype.delegate(['getJump', 'assigns', 'isStatement', 'isString'], function(it, arg){\n    return !this.tails.length && this.head[it](arg);\n  });\n  Chain.prototype.isComplex = function(){\n    return this.tails.length || this.head.isComplex();\n  };\n  Chain.prototype.isCallable = function(){\n    var that, ref$;\n    if (that = (ref$ = this.tails)[ref$.length - 1]) {\n      return !((ref$ = that.key) != null && ref$.items);\n    } else {\n      return this.head.isCallable();\n    }\n  };\n  Chain.prototype.isArray = function(){\n    var that, ref$;\n    if (that = (ref$ = this.tails)[ref$.length - 1]) {\n      return that.key instanceof Arr;\n    } else {\n      return this.head.isArray();\n    }\n  };\n  Chain.prototype.isRegex = function(){\n    return this.head.value === 'RegExp' && !this.tails[1] && this.tails[0] instanceof Call;\n  };\n  Chain.prototype.isAssignable = function(){\n    var tail, ref$, i$, len$;\n    if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {\n      return this.head.isAssignable();\n    }\n    if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {\n      return false;\n    }\n    for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {\n      tail = ref$[i$];\n      if (tail.assign) {\n        return false;\n      }\n    }\n    return true;\n  };\n  Chain.prototype.isSimpleAccess = function(){\n    return this.tails.length === 1 && !this.head.isComplex() && !this.tails[0].isComplex();\n  };\n  Chain.prototype.makeReturn = function(){\n    var ref$;\n    if (this.tails.length) {\n      return superclass.prototype.makeReturn.apply(this, arguments);\n    } else {\n      return (ref$ = this.head).makeReturn.apply(ref$, arguments);\n    }\n  };\n  Chain.prototype.getCall = function(){\n    var tail, ref$;\n    return (tail = (ref$ = this.tails)[ref$.length - 1]) instanceof Call && tail;\n  };\n  Chain.prototype.varName = function(){\n    var ref$, ref1$;\n    return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;\n  };\n  Chain.prototype.cacheReference = function(o){\n    var name, ref$, base, ref, bref, nref;\n    name = (ref$ = this.tails)[ref$.length - 1];\n    if (!this.isAssignable()) {\n      return this.unwrap().cache(o, true);\n    }\n    if (this.tails.length < 2 && !this.head.isComplex() && !(name != null && name.isComplex())) {\n      return [this, this];\n    }\n    base = Chain(this.head, this.tails.slice(0, -1));\n    if (base.isComplex()) {\n      ref = o.scope.temporary();\n      base = Chain(Assign(Var(ref), base));\n      bref = (ref$ = Var(ref), ref$.temp = true, ref$);\n    }\n    if (!name) {\n      return [base, bref];\n    }\n    if (name.isComplex()) {\n      ref = o.scope.temporary('key');\n      name = Index(Assign(Var(ref), name.key));\n      nref = Index((ref$ = Var(ref), ref$.temp = true, ref$));\n    }\n    return [base.add(name), Chain(bref || base.head, [nref || name])];\n  };\n  Chain.prototype.compileNode = function(o){\n    var head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, context, idt, func, base, news, ref$;\n    if (this.flip) {\n      util('flip');\n      util('curry');\n    }\n    head = this.head, tails = this.tails;\n    head.front = this.front;\n    head.newed = this.newed;\n    if (!tails.length) {\n      return head.compile(o);\n    }\n    if (that = this.unfoldAssign(o)) {\n      return that.compile(o);\n    }\n    for (i$ = 0, len$ = tails.length; i$ < len$; ++i$) {\n      t = tails[i$];\n      if (t.partialized) {\n        hasPartial = true;\n        break;\n      }\n    }\n    if (hasPartial) {\n      util('slice');\n      pre = [];\n      rest = [];\n      for (i$ = 0, len$ = tails.length; i$ < len$; ++i$) {\n        t = tails[i$];\n        broken = broken || t.partialized != null;\n        if (broken) {\n          rest.push(t);\n        } else {\n          pre.push(t);\n        }\n      }\n      if (rest != null) {\n        partial = rest[0], post = slice$.call(rest, 1);\n      }\n      this.tails = pre;\n      context = pre.length\n        ? Chain(head, slice$.call(pre, 0, -1))\n        : Literal('this');\n      return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial.args), Arr(partial.partialized)])])), post).compile(o);\n    }\n    if (tails[0] instanceof Call && !head.isCallable()) {\n      this.carp('invalid callee');\n    }\n    this.expandSlice(o);\n    this.expandVivify();\n    this.expandBind(o);\n    this.expandSplat(o);\n    this.expandStar(o);\n    if (this.splattedNewArgs) {\n      idt = o.indent + TAB;\n      func = Chain(this.head, tails.slice(0, -1));\n      return sn(null, \"(function(func, args, ctor) {\\n\" + idt + \"ctor.prototype = func.prototype;\\n\" + idt + \"var child = new ctor, result = func.apply(child, args), t;\\n\" + idt + \"return (t = typeof result)  == \\\"object\\\" || t == \\\"function\\\" ? result || child : child;\\n\" + TAB + \"})(\", func.compile(o), \", \", this.splattedNewArgs, \", function(){})\");\n    }\n    if (!this.tails.length) {\n      return this.head.compile(o);\n    }\n    base = [this.head.compile(o, LEVEL_CALL)];\n    news = [];\n    rest = [];\n    for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {\n      t = ref$[i$];\n      if (t['new']) {\n        news.push('new ');\n      }\n      rest.push(t.compile(o));\n    }\n    if ('.' === rest.join(\"\").charAt(0) && SIMPLENUM.test(base[0].toString())) {\n      base.push(' ');\n    }\n    return sn.apply(null, [null].concat(slice$.call(news), slice$.call(base), slice$.call(rest)));\n  };\n  Chain.prototype.unfoldSoak = function(o){\n    var that, ref$, i$, len$, i, node, ref1$, bust, test;\n    if (that = this.head.unfoldSoak(o)) {\n      (ref$ = that.then.tails).push.apply(ref$, this.tails);\n      return that;\n    }\n    for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {\n      i = i$;\n      node = ref$[i$];\n      if (ref1$ = node.soak, delete node.soak, ref1$) {\n        bust = Chain(this.head, this.tails.splice(0, i));\n        if (node.assign && !bust.isAssignable()) {\n          node.carp('invalid accessign');\n        }\n        if (i && (node.assign || node instanceof Call)) {\n          ref1$ = bust.cacheReference(o), test = ref1$[0], bust = ref1$[1];\n          if (bust instanceof Chain) {\n            (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);\n            bust = bust.head;\n          }\n          this.head = bust;\n        } else {\n          ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];\n        }\n        test = node instanceof Call\n          ? JS(\"typeof \" + test.compile(o, LEVEL_OP) + \" == 'function'\")\n          : Existence(test);\n        return ref1$ = If(test, this), ref1$.soak = true, ref1$.cond = this.cond, ref1$['void'] = this['void'], ref1$;\n      }\n    }\n  };\n  Chain.prototype.unfoldAssign = function(o){\n    var that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;\n    if (that = this.head.unfoldAssign(o)) {\n      (ref$ = that.right.tails).push.apply(ref$, this.tails);\n      return that;\n    }\n    for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {\n      i = i$;\n      index = ref$[i$];\n      if (op = index.assign) {\n        index.assign = '';\n        left = Chain(this.head, this.tails.splice(0, i)).expandSlice(o).unwrap();\n        if (left instanceof Arr) {\n          lefts = left.items;\n          rites = (this.head = Arr()).items;\n          for (j$ = 0, len1$ = lefts.length; j$ < len1$; ++j$) {\n            i = j$;\n            node = lefts[j$];\n            ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[0], lefts[i] = ref1$[1];\n          }\n        } else {\n          ref1$ = Chain(left).cacheReference(o), left = ref1$[0], this.head = ref1$[1];\n        }\n        if (op === '=') {\n          op = ':=';\n        }\n        return ref1$ = Assign(left, this, op), ref1$.access = true, ref1$;\n      }\n    }\n  };\n  Chain.prototype.expandSplat = function(o){\n    var tails, i, call, args, ctx, ref$;\n    tails = this.tails;\n    i = -1;\n    while (call = tails[++i]) {\n      if (!(args = call.args)) {\n        continue;\n      }\n      ctx = call.method === '.call' && (args = args.concat()).shift();\n      if (!!snEmpty(args = Splat.compileArray(o, args, true))) {\n        continue;\n      }\n      if (call['new']) {\n        this.splattedNewArgs = args;\n      } else {\n        if (!ctx && tails[i - 1] instanceof Index) {\n          ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];\n          i = 0;\n        }\n        call.method = '.apply';\n        call.args = [ctx || Literal('null'), JS(args)];\n      }\n    }\n  };\n  Chain.prototype.expandVivify = function(){\n    var tails, i, that, ref$, ref1$;\n    tails = this.tails;\n    i = 0;\n    while (i < tails.length) {\n      if (that = (ref1$ = (ref$ = tails[i++]).vivify, delete ref$.vivify, ref1$)) {\n        this.head = Assign(Chain(this.head, tails.splice(0, i)), that(), '=', '||');\n        i = 0;\n      }\n    }\n  };\n  Chain.prototype.expandBind = function(o){\n    var tails, i, that, obj, key, call;\n    tails = this.tails;\n    i = -1;\n    while (that = tails[++i]) {\n      if (that.symbol !== '.~') {\n        continue;\n      }\n      that.symbol = '';\n      obj = Chain(this.head, tails.splice(0, i)).unwrap();\n      key = tails.shift().key;\n      call = Call.make(Util('bind'), [obj, (key.reserved = true, key)]);\n      this.head = this.newed ? Parens(call, true) : call;\n      i = -1;\n    }\n  };\n  Chain.prototype.expandStar = function(o){\n    var tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;\n    tails = this.tails;\n    i = -1;\n    while (that = tails[++i]) {\n      if (that.args || that.stars || that.key instanceof Key) {\n        continue;\n      }\n      stars = that.stars = [];\n      that.eachChild(seek);\n      if (!stars.length) {\n        continue;\n      }\n      ref$ = Chain(this.head, tails.splice(0, i)).unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];\n      value = Chain(ref, [Index(Key('length'))]).compile(o);\n      for (i$ = 0, len$ = stars.length; i$ < len$; ++i$) {\n        star = stars[i$];\n        star.value = value;\n        star.isAssignable = YES;\n      }\n      this.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));\n      if (temps) {\n        o.scope.free(temps[0]);\n      }\n      i = -1;\n    }\n    function seek(it){\n      if (it.value === '*') {\n        stars.push(it);\n      } else if (!(it instanceof Index)) {\n        it.eachChild(seek);\n      }\n    }\n  };\n  Chain.prototype.expandSlice = function(o, assign){\n    var tails, i, tail, ref$, x;\n    tails = this.tails;\n    i = -1;\n    while (tail = tails[++i]) {\n      if ((ref$ = tail.key) != null && ref$.items) {\n        if (tails[i + 1] instanceof Call) {\n          tail.carp('calling a slice');\n        }\n        x = tails.splice(0, i + 1);\n        x = x.pop().key.toSlice(o, Chain(this.head, x).unwrap(), tail.symbol, assign);\n        this.head = (x.front = this.front, x);\n        i = -1;\n      }\n    }\n    return this;\n  };\n  return Chain;\n}(Node));\nexports.Call = Call = (function(superclass){\n  var prototype = extend$((import$(Call, superclass).displayName = 'Call', Call), superclass).prototype, constructor = Call;\n  function Call(args){\n    var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;\n    args || (args = []);\n    if (args.length === 1 && (splat = args[0]) instanceof Splat) {\n      if (splat.filler) {\n        this$.method = '.call';\n        args[0] = Literal('this');\n        args[1] = Splat(Literal('arguments'));\n      } else if (splat.it instanceof Arr) {\n        args = splat.it.items;\n      }\n    } else {\n      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {\n        i = i$;\n        a = args[i$];\n        if (a.value === '_') {\n          args[i] = Chain(Literal('void'));\n          args[i].placeholder = true;\n          ((ref$ = this$.partialized) != null\n            ? ref$\n            : this$.partialized = []).push(Chain(Literal(i)));\n        }\n      }\n    }\n    this$.args = args;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Call.prototype.children = ['args'];\n  Call.prototype.show = function(){\n    return [this['new']] + [this.method] + [this.soak ? '?' : void 8];\n  };\n  Call.prototype.compile = function(o){\n    var code, i$, ref$, len$, i, a;\n    code = [sn(this, this.method || '', '(') + (this.pipe ? \"\\n\" + o.indent : '')];\n    for (i$ = 0, len$ = (ref$ = this.args).length; i$ < len$; ++i$) {\n      i = i$;\n      a = ref$[i$];\n      code.push(i ? ', ' : '', a.compile(o, LEVEL_LIST));\n    }\n    code.push(sn(this, ')'));\n    return sn.apply(null, [null].concat(slice$.call(code)));\n  };\n  Call.make = function(callee, args, opts){\n    var call;\n    call = Call(args);\n    if (opts) {\n      import$(call, opts);\n    }\n    return Chain(callee).add(call);\n  };\n  Call.block = function(fun, args, method){\n    var ref$, ref1$;\n    return ref$ = Parens(Chain(fun, [(ref1$ = Call(args), ref1$.method = method, ref1$)]), true), ref$.calling = true, ref$;\n  };\n  Call.back = function(params, node, bound, curried, hushed, generator){\n    var fun, ref$, args, index, i$, len$, a;\n    fun = Fun(params, void 8, bound, curried, hushed, generator);\n    if (node instanceof Label) {\n      fun.name = node.label;\n      fun.labeled = true;\n      node = node.it;\n    }\n    if (!fun.hushed && (fun.hushed = node.op === '!')) {\n      node = node.it;\n    }\n    if ((ref$ = node.getCall()) != null) {\n      ref$.partialized = null;\n    }\n    args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;\n    index = 0;\n    for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {\n      a = args[i$];\n      if (a.placeholder) {\n        break;\n      }\n      ++index;\n    }\n    return node.back = (args[index] = fun).body, node;\n  };\n  Call['let'] = function(args, body, generator){\n    var params, res$, i$, len$, i, a, that, gotThis;\n    generator == null && (generator = false);\n    res$ = [];\n    for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {\n      i = i$;\n      a = args[i$];\n      if (that = a.op === '=' && !a.logic && a.right) {\n        args[i] = that;\n        if (i === 0 && (gotThis = a.left.value === 'this')) {\n          continue;\n        }\n        res$.push(a.left);\n      } else {\n        res$.push(Var(a.varName() || a.carp('invalid \"let\" argument')));\n      }\n    }\n    params = res$;\n    gotThis || args.unshift(Literal('this'));\n    return this.block(Fun(params, body, null, null, null, generator), args, '.call');\n  };\n  return Call;\n}(Node));\nList = (function(superclass){\n  var prototype = extend$((import$(List, superclass).displayName = 'List', List), superclass).prototype, constructor = List;\n  List.prototype.children = ['items'];\n  List.prototype.show = function(){\n    return this.name;\n  };\n  List.prototype.named = function(name){\n    this.name = name;\n    return this;\n  };\n  List.prototype.isEmpty = function(){\n    return !this.items.length;\n  };\n  List.prototype.assigns = function(it){\n    var i$, ref$, len$, node;\n    for (i$ = 0, len$ = (ref$ = this.items).length; i$ < len$; ++i$) {\n      node = ref$[i$];\n      if (node.assigns(it)) {\n        return true;\n      }\n    }\n  };\n  List.compile = function(o, items, deepEq){\n    var indent, level, code, i, that, target;\n    switch (items.length) {\n    case 0:\n      return '';\n    case 1:\n      return items[0].compile(o, LEVEL_LIST);\n    }\n    indent = o.indent, level = o.level;\n    o.indent = indent + TAB;\n    o.level = LEVEL_LIST;\n    code = [items[i = 0].compile(o)];\n    while (that = items[++i]) {\n      code.push(', ');\n      target = that;\n      if (deepEq) {\n        if (target instanceof Var && target.value === '_') {\n          target = Obj([Prop(Key('__placeholder__'), Literal(true))]);\n        } else if (target instanceof Obj || target instanceof Arr) {\n          target.deepEq = true;\n        }\n      }\n      code.push(target.compile(o));\n    }\n    if (~code.join(\"\").indexOf('\\n')) {\n      code = [\"\\n\" + o.indent].concat(slice$.call(code), [\"\\n\" + indent]);\n    }\n    o.indent = indent;\n    o.level = level;\n    return sn.apply(null, [this].concat(slice$.call(code)));\n  };\n  function List(){\n    List.superclass.apply(this, arguments);\n  }\n  return List;\n}(Node));\nexports.Obj = Obj = (function(superclass){\n  var prototype = extend$((import$(Obj, superclass).displayName = 'Obj', Obj), superclass).prototype, constructor = Obj;\n  function Obj(items){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.items = items || [];\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Obj.prototype.asObj = THIS;\n  Obj.prototype.toSlice = function(o, base, symbol, assign){\n    var items, ref$, ref, temps, i$, len$, i, node, name, chain, logic, key, val;\n    items = this.items;\n    if (items.length > 1) {\n      ref$ = base.cache(o), base = ref$[0], ref = ref$[1], temps = ref$[2];\n    } else {\n      ref = base;\n    }\n    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {\n      i = i$;\n      node = items[i$];\n      if (node.comment) {\n        continue;\n      }\n      if (node instanceof Prop || node instanceof Splat) {\n        node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);\n      } else {\n        if (logic = node.getDefault()) {\n          node = node.first;\n        }\n        if (node instanceof Parens) {\n          ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];\n          if (assign) {\n            ref$ = [node, key], key = ref$[0], node = ref$[1];\n          }\n          key = Parens(key);\n        } else {\n          key = node;\n        }\n        val = chain = Chain(base, [Index(node.maybeKey(), symbol)]);\n        if (logic) {\n          val = (logic.first = val, logic);\n        }\n        items[i] = Prop(key, val);\n      }\n      base = ref;\n    }\n    chain || this.carp('empty slice');\n    if (temps) {\n      (chain.head = Var(temps[0])).temp = true;\n    }\n    return this;\n  };\n  Obj.prototype.compileNode = function(o){\n    var items, code, idt, dic, i$, len$, i, node, logic, rest, ref$, multi, key, val;\n    items = this.items;\n    if (!items.length) {\n      return sn(this, this.front ? '({})' : '{}');\n    }\n    code = [];\n    idt = '\\n' + (o.indent += TAB);\n    dic = {};\n    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {\n      i = i$;\n      node = items[i$];\n      if (node.comment) {\n        code.push(idt, node.compile(o));\n        continue;\n      }\n      if (logic = node.getDefault()) {\n        node = node.first;\n      }\n      if (node instanceof Splat || (node.key || node) instanceof Parens) {\n        rest = items.slice(i);\n        break;\n      }\n      if (logic) {\n        if (node instanceof Prop) {\n          node.val = (logic.first = node.val, logic);\n        } else {\n          node = Prop(node, (logic.first = node, logic));\n        }\n      }\n      if (this.deepEq && node instanceof Prop) {\n        if (node.val instanceof Var && node.val.value === '_') {\n          node.val = Obj([Prop(Key('__placeholder__'), Literal(true))]);\n        } else if ((ref$ = node.val) instanceof Obj || ref$ instanceof Arr) {\n          node.val.deepEq = true;\n        }\n      }\n      if (multi) {\n        code.push(',');\n      } else {\n        multi = true;\n      }\n      code.push(idt);\n      if (node instanceof Prop) {\n        key = node.key, val = node.val;\n        if (node.accessor) {\n          code.push(node.compileAccessor(o, key = key.compile(o)));\n        } else {\n          val.ripName(key);\n          code.push(key = key.compile(o), \": \", val.compile(o, LEVEL_LIST));\n        }\n      } else {\n        code.push(key = node.compile(o), \": \", key);\n      }\n      ID.test(key) || (key = Function(\"return \" + key)());\n      if (!(dic[key + \".\"] ^= 1)) {\n        node.carp(\"duplicate property \\\"\" + key + \"\\\"\");\n      }\n    }\n    if (code.join(\"\")) {\n      code.push('\\n' + this.tab);\n    }\n    code = sn.apply(null, [null, sn(this, \"{\")].concat(slice$.call(code), [sn(this, \"}\")]));\n    rest && (code = Import(JS(code), Obj(rest)).compile((o.indent = this.tab, o)));\n    if (this.front && '{' === code.toString().charAt()) {\n      return sn(null, \"(\", code, \")\");\n    } else {\n      return code;\n    }\n  };\n  return Obj;\n}(List));\nexports.Prop = Prop = (function(superclass){\n  var prototype = extend$((import$(Prop, superclass).displayName = 'Prop', Prop), superclass).prototype, constructor = Prop;\n  function Prop(key, val){\n    var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.key = key;\n    this$.val = val;\n    if (key.value === '...') {\n      return Splat(this$.val);\n    }\n    if (that = val.getAccessors()) {\n      this$.val = that;\n      for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {\n        fun = that[i$];\n        fun.x = (fun.hushed = fun.params.length) ? 's' : 'g';\n      }\n      this$['accessor'] = 'accessor';\n    }\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Prop.prototype.children = ['key', 'val'];\n  Prop.prototype.show = function(){\n    return this.accessor;\n  };\n  Prop.prototype.assigns = function(it){\n    var ref$;\n    return typeof (ref$ = this.val).assigns == 'function' ? ref$.assigns(it) : void 8;\n  };\n  Prop.prototype.compileAccessor = function(o, key){\n    var funs, code, i$, len$, fun;\n    funs = this.val;\n    if (funs[1] && funs[0].params.length + funs[1].params.length !== 1) {\n      funs[0].carp('invalid accessor parameter');\n    }\n    code = [];\n    for (i$ = 0, len$ = funs.length; i$ < len$; ++i$) {\n      fun = funs[i$];\n      fun.accessor = true;\n      code.push(fun.x, \"et \", key, fun.compile(o, LEVEL_LIST).toString().slice(8), ',\\n' + o.indent);\n    }\n    code.pop();\n    return sn.apply(null, [null].concat(slice$.call(code)));\n  };\n  Prop.prototype.compileDescriptor = function(o){\n    var obj, i$, ref$, len$, fun;\n    obj = Obj();\n    for (i$ = 0, len$ = (ref$ = this.val).length; i$ < len$; ++i$) {\n      fun = ref$[i$];\n      obj.items.push(Prop(Key(fun.x + 'et'), fun));\n    }\n    obj.items.push(Prop(Key('configurable'), Literal(true)));\n    obj.items.push(Prop(Key('enumerable'), Literal(true)));\n    return obj.compile(o);\n  };\n  return Prop;\n}(Node));\nexports.Arr = Arr = (function(superclass){\n  var prototype = extend$((import$(Arr, superclass).displayName = 'Arr', Arr), superclass).prototype, constructor = Arr;\n  function Arr(items){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.items = items || [];\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Arr.prototype.isArray = YES;\n  Arr.prototype.asObj = function(){\n    var i, item;\n    return Obj((function(){\n      var i$, ref$, len$, results$ = [];\n      for (i$ = 0, len$ = (ref$ = this.items).length; i$ < len$; ++i$) {\n        i = i$;\n        item = ref$[i$];\n        results$.push(Prop(Literal(i), item));\n      }\n      return results$;\n    }.call(this)));\n  };\n  Arr.prototype.toSlice = function(o, base, symbol){\n    var items, ref$, ref, i$, len$, i, item, splat, chain;\n    items = this.items;\n    if (items.length > 1) {\n      ref$ = base.cache(o), base = ref$[0], ref = ref$[1];\n    } else {\n      ref = base;\n    }\n    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {\n      i = i$;\n      item = items[i$];\n      if (splat = item instanceof Splat) {\n        item = item.it;\n      }\n      if (item.isEmpty()) {\n        continue;\n      }\n      chain = Chain(base, [Index(item, symbol)]);\n      items[i] = splat ? Splat(chain) : chain;\n      base = ref;\n    }\n    chain || this.carp('empty slice');\n    return this;\n  };\n  Arr.prototype.compile = function(o){\n    var items, code;\n    items = this.items;\n    if (!items.length) {\n      return sn(this, '[]');\n    }\n    if (!snEmpty(code = Splat.compileArray(o, items))) {\n      return this.newed\n        ? sn(this, \"(\", code, \")\")\n        : sn(this, code);\n    }\n    return sn(null, sn(this, \"[\"), List.compile(o, items, this.deepEq), sn(this, \"]\"));\n  };\n  Arr.maybe = function(nodes){\n    if (nodes.length === 1 && !(nodes[0] instanceof Splat)) {\n      return nodes[0];\n    }\n    return constructor(nodes);\n  };\n  Arr.wrap = function(it){\n    return constructor([Splat((it.isArray = YES, it))]);\n  };\n  return Arr;\n}(List));\nexports.Yield = Yield = (function(superclass){\n  var prototype = extend$((import$(Yield, superclass).displayName = 'Yield', Yield), superclass).prototype, constructor = Yield;\n  function Yield(op, it){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.op = op;\n    this$.it = it;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Yield.prototype.children = ['it'];\n  Yield.prototype.show = function(){\n    if (this.op === 'yieldfrom') {\n      return 'from';\n    } else {\n      return '';\n    }\n  };\n  prototype.delegate(['isCallable'], function(){\n    return true;\n  });\n  Yield.prototype.compileNode = function(o){\n    var code;\n    code = [];\n    if (this.op === 'yieldfrom') {\n      code.push('yield*');\n    } else {\n      code.push('yield');\n    }\n    if (this.it) {\n      code.push(\" \" + this.it.compile(o, LEVEL_OP + PREC.unary));\n    }\n    return sn.apply(null, [this, \"(\"].concat(slice$.call(code), [\")\"]));\n  };\n  return Yield;\n}(Node));\nexports.Unary = Unary = (function(superclass){\n  var prototype = extend$((import$(Unary, superclass).displayName = 'Unary', Unary), superclass).prototype, constructor = Unary;\n  function Unary(op, it, flag){\n    var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;\n    if (it != null) {\n      if (that = !flag && it.unaries) {\n        that.push(op);\n        return it;\n      }\n      switch (op) {\n      case '!':\n        if (flag) {\n          break;\n        }\n        if (it instanceof Fun && !it.hushed) {\n          return it.hushed = true, it;\n        }\n        return it.invert();\n      case '++':\n      case '--':\n        if (flag) {\n          this$.post = true;\n        }\n        break;\n      case 'new':\n        if (it instanceof Existence && !it.negated) {\n          it = Chain(it).add(Call());\n        }\n        it.newed = true;\n        for (i$ = 0, len$ = (ref$ = it.tails || '').length; i$ < len$; ++i$) {\n          node = ref$[i$];\n          if (node instanceof Call && !node['new']) {\n            if (node.method === '.call') {\n              node.args.shift();\n            }\n            node['new'] = 'new';\n            node.method = '';\n            return it;\n          }\n        }\n        break;\n      case '~':\n        if (it instanceof Fun && it.statement && !it.bound) {\n          return it.bound = 'this$', it;\n        }\n      }\n    }\n    this$.op = op;\n    this$.it = it;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Unary.prototype.children = ['it'];\n  Unary.prototype.show = function(){\n    return [this.post ? '@' : void 8] + this.op;\n  };\n  Unary.prototype.isCallable = function(){\n    var ref$;\n    return ((ref$ = this.op) === 'do' || ref$ === 'new' || ref$ === 'delete') || this.it == null;\n  };\n  Unary.prototype.isArray = function(){\n    return this.it instanceof Arr && this.it.items.length || this.it instanceof Chain && this.it.isArray();\n  };\n  Unary.prototype.isString = function(){\n    var ref$;\n    return (ref$ = this.op) === 'typeof' || ref$ === 'classof';\n  };\n  Unary.prototype.invert = function(){\n    var ref$;\n    if (this.op === '!' && ((ref$ = this.it.op) === '!' || ref$ === '<' || ref$ === '>' || ref$ === '<=' || ref$ === '>=' || ref$ === 'of' || ref$ === 'instanceof')) {\n      return this.it;\n    }\n    return constructor('!', this, true);\n  };\n  Unary.prototype.unfoldSoak = function(o){\n    var ref$;\n    return ((ref$ = this.op) === '++' || ref$ === '--' || ref$ === 'delete') && this.it != null && If.unfoldSoak(o, this, 'it');\n  };\n  Unary.prototype.getAccessors = function(){\n    var items;\n    if (this.op !== '~') {\n      return;\n    }\n    if (this.it instanceof Fun) {\n      return [this.it];\n    }\n    if (this.it instanceof Arr) {\n      items = this.it.items;\n      if (!items[2] && items[0] instanceof Fun && items[1] instanceof Fun) {\n        return items;\n      }\n    }\n  };\n  function crement(it){\n    return {\n      '++': 'in',\n      '--': 'de'\n    }[it] + 'crement';\n  }\n  Unary.prototype.compileNode = function(o){\n    var that, op, it, x, code;\n    if (this.it == null) {\n      return this.compileAsFunc(o);\n    }\n    if (that = this.compileSpread(o)) {\n      return that;\n    }\n    op = this.op, it = this.it;\n    switch (op) {\n    case '!':\n      it.cond = true;\n      break;\n    case 'new':\n      it.isCallable() || it.carp('invalid constructor');\n      break;\n    case 'do':\n      if (o.level === LEVEL_TOP && it instanceof Fun && it.isStatement()) {\n        return sn(this, it.compile(o), \" \", Unary('do', Var(it.name)).compile(o));\n      }\n      x = Parens(it instanceof Existence && !it.negated\n        ? Chain(it).add(Call())\n        : Call.make(it));\n      return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));\n    case 'delete':\n      if (it instanceof Var || !it.isAssignable()) {\n        this.carp('invalid delete');\n      }\n      if (o.level && !this['void']) {\n        return this.compilePluck(o);\n      }\n      break;\n    case '++':\n    case '--':\n      it.isAssignable() || this.carp('invalid ' + crement(op));\n      if (that = it instanceof Var && o.scope.checkReadOnly(it.value)) {\n        this.carp(crement(op) + \" of \" + that + \" \\\"\" + it.value + \"\\\"\", ReferenceError);\n      }\n      if (this.post) {\n        it.front = this.front;\n      }\n      break;\n    case '^^':\n      return sn(this, util('clone'), \"(\", it.compile(o, LEVEL_LIST), \")\");\n    case 'jsdelete':\n      return sn(this, \"delete \", it.compile(o, LEVEL_LIST));\n    case 'classof':\n      return sn(this, util('toString'), \".call(\", it.compile(o, LEVEL_LIST), \").slice(8, -1)\");\n    }\n    code = [it.compile(o, LEVEL_OP + PREC.unary)];\n    if (this.post) {\n      code.push(op);\n    } else {\n      if ((op === 'new' || op === 'typeof' || op === 'delete') || (op === '+' || op === '-') && op === code.join(\"\").charAt()) {\n        op += ' ';\n      }\n      code.unshift(op);\n    }\n    if (o.level < LEVEL_CALL) {\n      return sn.apply(null, [this].concat(slice$.call(code)));\n    } else {\n      return sn.apply(null, [this, \"(\"].concat(slice$.call(code), [\")\"]));\n    }\n  };\n  Unary.prototype.compileSpread = function(o){\n    var it, ops;\n    it = this.it;\n    ops = [this];\n    for (; it instanceof constructor; it = it.it) {\n      ops.push(it);\n    }\n    if (!(it instanceof Splat && (it = it.it.expandSlice(o).unwrap()) instanceof List)) {\n      return '';\n    }\n    return this.compileSpreadOver(o, it, function(node){\n      var i$, ref$, op;\n      for (i$ = (ref$ = ops).length - 1; i$ >= 0; --i$) {\n        op = ref$[i$];\n        node = constructor(op.op, node, op.post);\n      }\n      return node;\n    });\n  };\n  Unary.prototype.compilePluck = function(o){\n    var ref$, get, del, code, ref;\n    ref$ = Chain(this.it).cacheReference(o), get = ref$[0], del = ref$[1];\n    code = [ref = o.scope.temporary(), \" = \", get.compile(o, LEVEL_LIST), \", delete \", del.compile(o, LEVEL_LIST), \", \", o.scope.free(ref)];\n    if (o.level < LEVEL_LIST) {\n      return sn.apply(null, [this].concat(slice$.call(code)));\n    } else {\n      return sn.apply(null, [this, \"(\"].concat(slice$.call(code), [\")\"]));\n    }\n  };\n  Unary.prototype.compileAsFunc = function(o){\n    if (this.op === '!') {\n      return sn(this, util('not'));\n    } else {\n      return sn(this, \"(\", Fun([], Block(Unary(this.op, Chain(Var('it'))))).compile(o), \")\");\n    }\n  };\n  return Unary;\n}(Node));\nexports.Binary = Binary = (function(superclass){\n  var COMPARER, INVERSIONS, prototype = extend$((import$(Binary, superclass).displayName = 'Binary', Binary), superclass).prototype, constructor = Binary;\n  function Binary(op, first, second, destructuring){\n    var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;\n    if (destructuring) {\n      logic = op.logic;\n      if (toString$.call(destructuring).slice(8, -1) === 'String') {\n        logic = destructuring;\n      }\n      op = (function(){\n        switch (false) {\n        case !(that = logic):\n          return that;\n        case op !== '=':\n          return '?';\n        default:\n          return '=';\n        }\n      }());\n    }\n    this$.partial = first == null || second == null;\n    if (!this$.partial) {\n      if ('=' === op.charAt(op.length - 1) && ((ref$ = op.charAt(op.length - 2)) !== '=' && ref$ !== '<' && ref$ !== '>' && ref$ !== '!')) {\n        return Assign(first.unwrap(), second, op);\n      }\n      switch (op) {\n      case 'in':\n        return new In(first, second);\n      case 'with':\n        return new Import(Unary('^^', first), second, false);\n      case '<<<':\n      case '<<<<':\n        return Import(first, second, op === '<<<<');\n      case '<|':\n        return Block(first).pipe(second, op);\n      case '|>':\n        return Block(second).pipe(first, '<|');\n      case '.':\n      case '.~':\n        return Chain(first).add(Index(second, op));\n      }\n    }\n    this$.op = op;\n    this$.first = first;\n    this$.second = second;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Binary.prototype.children = ['first', 'second'];\n  Binary.prototype.show = function(){\n    return this.op;\n  };\n  Binary.prototype.isCallable = function(){\n    var ref$;\n    return this.partial || ((ref$ = this.op) === '&&' || ref$ === '||' || ref$ === '?' || ref$ === '<<' || ref$ === '>>') && this.first.isCallable() && this.second.isCallable();\n  };\n  Binary.prototype.isArray = function(){\n    switch (this.op) {\n    case '*':\n      return this.first.isArray();\n    case '/':\n      return this.second.isMatcher();\n    }\n  };\n  Binary.prototype.isString = function(){\n    switch (this.op) {\n    case '+':\n    case '*':\n      return this.first.isString() || this.second.isString();\n    case '-':\n      return this.second.isMatcher();\n    }\n  };\n  COMPARER = /^(?:[!=]=|[<>])=?$/;\n  INVERSIONS = {\n    '===': '!==',\n    '!==': '===',\n    '==': '!=',\n    '!=': '=='\n  };\n  Binary.prototype.invert = function(){\n    var that;\n    if (that = !COMPARER.test(this.second.op) && INVERSIONS[this.op]) {\n      this.op = that;\n      this.wasInverted = true;\n      return this;\n    }\n    return Unary('!', Parens(this), true);\n  };\n  Binary.prototype.invertIt = function(){\n    this.inverted = true;\n    return this;\n  };\n  Binary.prototype.getDefault = function(){\n    switch (this.op) {\n    case '?':\n    case '||':\n    case '&&':\n      return this;\n    }\n  };\n  Binary.prototype.xorChildren = function(test){\n    var ref$, ref1$, first;\n    if (!(!(ref$ = first = test(this.first)) !== !(ref1$ = test(this.second)) && (ref$ || ref1$))) {\n      return false;\n    }\n    return first\n      ? [this.first, this.second]\n      : [this.second, this.first];\n  };\n  Binary.prototype.compileNode = function(o){\n    var top, rite, items, that, ref$, code, level, this$ = this;\n    if (this.partial) {\n      return this.compilePartial(o);\n    }\n    switch (this.op) {\n    case '?':\n      return this.compileExistence(o);\n    case '*':\n      if (this.second.isString()) {\n        return this.compileJoin(o);\n      }\n      if (this.first.isString() || this.first.isArray()) {\n        return this.compileRepeat(o);\n      }\n      break;\n    case '-':\n      if (this.second.isMatcher()) {\n        return this.compileRemove(o);\n      }\n      break;\n    case '/':\n      if (this.second.isMatcher()) {\n        return this.compileSplit(o);\n      }\n      break;\n    case '**':\n    case '^':\n      return this.compilePow(o);\n    case '<?':\n    case '>?':\n      return this.compileMinMax(o);\n    case '<<':\n    case '>>':\n      return this.compileCompose(o);\n    case '++':\n      return this.compileConcat(o);\n    case '%%':\n      return this.compileMod(o);\n    case 'xor':\n      return this.compileXor(o);\n    case '&&':\n    case '||':\n      if (top = this['void'] || !o.level) {\n        this.second['void'] = true;\n      }\n      if (top || this.cond) {\n        this.first.cond = true;\n        this.second.cond = true;\n      }\n      break;\n    case 'instanceof':\n      rite = this.second.expandSlice(o).unwrap(), items = rite.items;\n      if (rite instanceof Arr) {\n        if (items[1]) {\n          return this.compileAnyInstanceOf(o, items);\n        }\n        this.second = items[0] || rite;\n      }\n      this.second.isCallable() || this.second.carp('invalid instanceof operand');\n      break;\n    case '====':\n    case '!===':\n      this.op = this.op.slice(0, 3);\n      // fallthrough\n    case '<==':\n    case '>==':\n    case '<<=':\n    case '>>=':\n      return this.compileDeepEq(o);\n    default:\n      if (COMPARER.test(this.op)) {\n        if (that = ((ref$ = this.op) === '===' || ref$ === '!==') && this.xorChildren(function(it){\n          return it.isRegex();\n        })) {\n          return this.compileRegexEquals(o, that);\n        }\n        if (this.op === '===' && (this.first instanceof Literal && this.second instanceof Literal) && this.first.isWhat() !== this.second.isWhat()) {\n          if (typeof console != 'undefined' && console !== null) {\n            console.warn(\"WARNING: strict comparison of two different types will always be false: \" + this.first.value + \" == \" + this.second.value);\n          }\n        }\n      }\n      if (COMPARER.test(this.op) && COMPARER.test(this.second.op)) {\n        return this.compileChain(o);\n      }\n    }\n    this.first.front = this.front;\n    code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), \" \", this.mapOp(this.op), \" \", this.second.compile(o, level)];\n    if (o.level <= level) {\n      return sn.apply(null, [this].concat(slice$.call(code)));\n    } else {\n      return sn.apply(null, [this, \"(\"].concat(slice$.call(code), [\")\"]));\n    }\n  };\n  Binary.prototype.mapOp = function(op){\n    var that;\n    switch (false) {\n    case !(that = op.match(/\\.([&\\|\\^]|<<|>>>?)\\./)):\n      return that[1];\n    case op !== 'of':\n      return 'in';\n    default:\n      return op;\n    }\n  };\n  Binary.prototype.compileChain = function(o){\n    var code, level, ref$, sub;\n    code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op])];\n    ref$ = this.second.first.cache(o, true), sub = ref$[0], this.second.first = ref$[1];\n    code.push(\" \", this.op, \" \", sub.compile(o, level), \" && \", this.second.compile(o, LEVEL_OP));\n    if (o.level <= LEVEL_OP) {\n      return sn.apply(null, [this].concat(slice$.call(code)));\n    } else {\n      return sn.apply(null, [this, \"(\"].concat(slice$.call(code), [\")\"]));\n    }\n  };\n  Binary.prototype.compileExistence = function(o){\n    var x;\n    if (this['void'] || !o.level) {\n      x = Binary('&&', Existence(this.first, true), this.second);\n      return (x['void'] = true, x).compileNode(o);\n    }\n    x = this.first.cache(o, true);\n    return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).compileExpression(o));\n  };\n  Binary.prototype.compileAnyInstanceOf = function(o, items){\n    var ref$, sub, ref, test, i$, len$, item;\n    ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];\n    test = Binary('instanceof', sub, items.shift());\n    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {\n      item = items[i$];\n      test = Binary('||', test, Binary('instanceof', ref, item));\n    }\n    return sn(this, Parens(test).compile(o));\n  };\n  Binary.prototype.compileMinMax = function(o){\n    var lefts, rites, x;\n    lefts = this.first.cache(o, true);\n    rites = this.second.cache(o, true);\n    x = Binary(this.op.charAt(), lefts[0], rites[0]);\n    return sn(this, If(x, lefts[1]).addElse(rites[1]).compileExpression(o));\n  };\n  Binary.prototype.compileMethod = function(o, klass, method, arg){\n    var args;\n    args = [this.second].concat(arg || []);\n    if (this.first[\"is\" + klass]()) {\n      return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));\n    } else {\n      args.unshift(this.first);\n      return sn(this, Call.make(JS(util(method) + '.call'), args).compile(o));\n    }\n  };\n  Binary.prototype.compileJoin = function(it){\n    return this.compileMethod(it, 'Array', 'join');\n  };\n  Binary.prototype.compileRemove = function(it){\n    return this.compileMethod(it, 'String', 'replace', JS(\"''\"));\n  };\n  Binary.prototype.compileSplit = function(it){\n    return this.compileMethod(it, 'String', 'split');\n  };\n  Binary.prototype.compileRepeat = function(o){\n    var x, n, items, arr, arrCode, refs, i$, len$, i, item, ref$, q;\n    x = this.first, n = this.second;\n    items = (x = x.expandSlice(o).unwrap()).items;\n    arr = x.isArray() && 'Array';\n    if (items && !snEmpty(arrCode = Splat.compileArray(o, items))) {\n      x = JS(arrCode);\n      items = null;\n    }\n    if (arr && !items || !(n instanceof Literal && n.value < 0x20)) {\n      return sn(this, Call.make(Util('repeat' + (arr || 'String')), [x, n]).compile(o));\n    }\n    n = +n.value;\n    if (1 <= n && n < 2) {\n      return sn(this, x.compile(o));\n    }\n    if (items) {\n      if (n < 1) {\n        return sn(this, Block(items).add(JS('[]')).compile(o));\n      }\n      refs = [];\n      for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {\n        i = i$;\n        item = items[i$];\n        ref$ = item.cache(o, 1), items[i] = ref$[0], refs[refs.length] = ref$[1];\n      }\n      items.push((ref$ = JS(), ref$.compile = function(){\n        return sn.apply(null, [this].concat(slice$.call((repeatArray$([\", \", List.compile(o, refs)], n - 1)).slice(1))));\n      }, ref$));\n      return sn(this, x.compile(o));\n    } else if (x instanceof Literal) {\n      return sn(this, (q = (x = x.compile(o).toString()).charAt()) + repeatString$(x.slice(1, -1) + \"\", n) + q);\n    } else {\n      if (n < 1) {\n        return sn(this, Block(x.it).add(JS(\"''\")).compile(o));\n      }\n      x = (refs = x.cache(o, 1, LEVEL_OP))[0] + repeatString$(\" + \" + refs[1], n - 1);\n      if (o.level < LEVEL_OP + PREC['+']) {\n        return sn(this, x);\n      } else {\n        return sn(this, \"(\", x, \")\");\n      }\n    }\n  };\n  Binary.prototype.compilePow = function(o){\n    return sn(null, Call.make(CopyL(this, JS('Math.pow')), [this.first, this.second]).compile(o));\n  };\n  Binary.prototype.compileConcat = function(o){\n    var f;\n    f = function(x){\n      switch (false) {\n      case !(x instanceof Binary && x.op === '++'):\n        return f(x.first).concat(f(x.second));\n      default:\n        return [x];\n      }\n    };\n    return sn(null, Chain(this.first).add(CopyL(this, Index(Key('concat'), '.', true))).add(Call(f(this.second))).compile(o));\n  };\n  Binary.prototype.compileCompose = function(o){\n    var op, functions, x;\n    op = this.op;\n    functions = [this.first];\n    x = this.second;\n    while (x instanceof Binary && x.op === op && !x.partial) {\n      functions.push(x.first);\n      x = x.second;\n    }\n    functions.push(x);\n    if (op === '<<') {\n      functions.reverse();\n    }\n    return sn(this, Chain(Var(util('compose'))).add(Call(functions)).compile(o));\n  };\n  Binary.prototype.compileMod = function(o){\n    var ref, code;\n    ref = o.scope.temporary();\n    code = [sn(this, \"(((\"), this.first.compile(o), sn(this, \") % (\"), sn(this, ref, \" = \"), this.second.compile(o), sn(this, \") + \", ref, \") % \", ref, \")\")];\n    o.scope.free(ref);\n    return sn.apply(null, [null].concat(slice$.call(code)));\n  };\n  Binary.prototype.compilePartial = function(o){\n    var vit, x, y;\n    vit = Var('it');\n    switch (false) {\n    case !(this.first == null && this.second == null):\n      x = Var('x$');\n      y = Var('y$');\n      return sn(this, Fun([x, y], Block(Binary(this.op, x, y).invertCheck(this)), false, true).compile(o));\n    case this.first == null:\n      return sn(this, \"(\", Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), \")\");\n    default:\n      return sn(this, \"(\", Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), \")\");\n    }\n  };\n  Binary.prototype.compileRegexEquals = function(o, arg$){\n    var regex, target, method;\n    regex = arg$[0], target = arg$[1];\n    if (this.op === '===') {\n      method = this.wasInverted ? 'test' : 'exec';\n      return sn(this, Chain(regex).add(Index(Key(method))).add(Call([target])).compile(o));\n    } else {\n      return sn(this, Unary('!', Chain(regex).add(Index(Key('test'))).add(Call([target]))).compile(o));\n    }\n  };\n  Binary.prototype.compileDeepEq = function(o){\n    var ref$, negate, i$, len$, x, r;\n    if ((ref$ = this.op) === '>==' || ref$ === '>>=') {\n      ref$ = [this.second, this.first], this.first = ref$[0], this.second = ref$[1];\n      this.op = this.op === '>==' ? '<==' : '<<=';\n    }\n    if (this.op === '!==') {\n      this.op = '===';\n      negate = true;\n    }\n    for (i$ = 0, len$ = (ref$ = [this.first, this.second]).length; i$ < len$; ++i$) {\n      x = ref$[i$];\n      if (x instanceof Obj || x instanceof Arr) {\n        x.deepEq = true;\n      }\n    }\n    r = Chain(Var(util('deepEq'))).add(Call([this.first, this.second, Literal(\"'\" + this.op + \"'\")]));\n    return sn(this, (negate ? Unary('!', r) : r).compile(o));\n  };\n  Binary.prototype.compileXor = function(o){\n    var left, right;\n    left = Chain(this.first).cacheReference(o);\n    right = Chain(this.second).cacheReference(o);\n    return sn(this, Binary('&&', Binary('!==', Unary('!', left[0]), Unary('!', right[0])), Parens(Binary('||', left[1], right[1]))).compile(o));\n  };\n  return Binary;\n}(Node));\nexports.Assign = Assign = (function(superclass){\n  var prototype = extend$((import$(Assign, superclass).displayName = 'Assign', Assign), superclass).prototype, constructor = Assign;\n  function Assign(left, rite, op, logic, defParam){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.left = left;\n    this$.op = op || '=';\n    this$.logic = logic || this$.op.logic;\n    this$.defParam = defParam;\n    this$.opLoc = this$.op;\n    this$.op += '';\n    this$[rite instanceof Node ? 'right' : 'unaries'] = rite;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Assign.prototype.children = ['left', 'right'];\n  Assign.prototype.show = function(){\n    return [void 8].concat(this.unaries).reverse().join(' ') + [this.logic] + this.op;\n  };\n  Assign.prototype.assigns = function(it){\n    return this.left.assigns(it);\n  };\n  prototype.delegate(['isCallable', 'isRegex'], function(it){\n    var ref$;\n    return ((ref$ = this.op) === '=' || ref$ === ':=') && this.right && this.right[it]();\n  });\n  Assign.prototype.isArray = function(){\n    switch (this.op) {\n    case '=':\n    case ':=':\n      return this.right && this.right.isArray();\n    case '/=':\n      return this.right && this.right.isMatcher();\n    }\n  };\n  Assign.prototype.isString = function(){\n    switch (this.op) {\n    case '=':\n    case ':=':\n    case '+=':\n    case '*=':\n      return this.right && this.right.isString();\n    case '-=':\n      return this.right && this.right.isMatcher();\n    }\n  };\n  Assign.prototype.unfoldSoak = function(o){\n    var that, ref$, ref1$, rite, temps;\n    if (this.left instanceof Existence) {\n      if (that = (ref1$ = (ref$ = this.left = this.left.it).name, delete ref$.name, ref1$)) {\n        rite = this.right;\n        rite = Assign(this.right = Var(that), rite);\n      } else {\n        ref$ = this.right.cache(o), rite = ref$[0], this.right = ref$[1], temps = ref$[2];\n      }\n      return ref$ = If(Existence(rite), this), ref$.temps = temps, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;\n    }\n    return If.unfoldSoak(o, this, 'left');\n  };\n  Assign.prototype.unfoldAssign = function(){\n    return this.access && this;\n  };\n  Assign.prototype.compileNode = function(o){\n    var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;\n    if (this.left instanceof Slice && this.op === '=') {\n      return this.compileSplice(o);\n    }\n    left = this.left;\n    if (sp = this.left instanceof Splat) {\n      left = left.it;\n    }\n    left = left.expandSlice(o, true).unwrap();\n    if (sp) {\n      left instanceof List || this.left.carp('invalid splat');\n      return this.compileSpread(o, left);\n    }\n    if (!this.right) {\n      left.isAssignable() || left.carp('invalid unary assign');\n      ref$ = Chain(left).cacheReference(o), left = ref$[0], this.right = ref$[1];\n      for (i$ = 0, len$ = (ref$ = this.unaries).length; i$ < len$; ++i$) {\n        op = ref$[i$];\n        this.right = Unary(op, this.right);\n      }\n    }\n    if (left.isEmpty()) {\n      return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));\n    }\n    if (left.getDefault()) {\n      this.right = Binary(left.op, this.right, left.second);\n      left = left.first;\n    }\n    if (left.items) {\n      return this.compileDestructuring(o, left);\n    }\n    left.isAssignable() || left.carp('invalid assign');\n    if (this.logic) {\n      return this.compileConditional(o, left);\n    }\n    op = this.op, right = this.right;\n    if (op === '<?=' || op === '>?=') {\n      return this.compileMinMax(o, left, right);\n    }\n    if ((op === '**=' || op === '^=' || op === '%%=' || op === '++=' || op === '|>=') || op === '*=' && right.isString() || (op === '-=' || op === '/=') && right.isMatcher()) {\n      ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];\n      right = Binary(op.slice(0, -1), reft, right);\n      op = ':=';\n    }\n    if (op === '.&.=' || op === '.|.=' || op === '.^.=' || op === '.<<.=' || op === '.>>.=' || op === '.>>>.=') {\n      op = op.slice(1, -2) + '=';\n    }\n    (right = right.unparen()).ripName(left = left.unwrap());\n    sign = sn(this.opLoc, \" \", op.replace(':', ''), \" \");\n    name = (left.front = true, left).compile(o, LEVEL_LIST);\n    if (lvar = left instanceof Var) {\n      if (op === '=') {\n        o.scope.declare(name.toString(), left, this['const'] || !this.defParam && o['const'] && '$' !== name.toString().slice(-1));\n      } else if (that = o.scope.checkReadOnly(name.toString())) {\n        left.carp(\"assignment to \" + that + \" \\\"\" + name + \"\\\"\", ReferenceError);\n      }\n    }\n    if (left instanceof Chain && right instanceof Fun) {\n      protoSplit = name.toString().split('.prototype.');\n      dotSplit = name.toString().split('.');\n      if (protoSplit.length > 1) {\n        right.inClass = protoSplit[0];\n      } else if (dotSplit.length > 1) {\n        right.inClassStatic = slice$.call(dotSplit, 0, -1).join('');\n      }\n    }\n    code = !o.level && right instanceof While && !right['else'] && (lvar || left instanceof Chain && left.isSimpleAccess())\n      ? (empty = right.objComp ? '{}' : '[]', [res = o.scope.temporary('res'), \" = \" + empty + \";\\n\" + this.tab, right.makeReturn(res).compile(o), \"\\n\" + this.tab, name, sign, o.scope.free(res)])\n      : [name, sign, right.compile(o, LEVEL_LIST)];\n    if (o.level > LEVEL_LIST) {\n      code = [\"(\"].concat(slice$.call(code), [\")\"]);\n    }\n    return sn.apply(null, [null].concat(slice$.call(code)));\n  };\n  Assign.prototype.compileConditional = function(o, left){\n    var lefts, morph;\n    if (left instanceof Var && in$(this.logic, ['?']) && this.op === '=') {\n      o.scope.declare(left.value, left);\n    }\n    lefts = Chain(left).cacheReference(o);\n    o.level += LEVEL_OP < o.level;\n    morph = Binary(this.logic, lefts[0], (this.logic = false, this.left = lefts[1], this));\n    return sn(this, (morph['void'] = this['void'], morph).compileNode(o));\n  };\n  Assign.prototype.compileMinMax = function(o, left, right){\n    var lefts, rites, test, put, ref$;\n    lefts = Chain(left).cacheReference(o);\n    rites = right.cache(o, true);\n    test = Binary(this.op.replace('?', ''), lefts[0], rites[0]);\n    put = Assign(lefts[1], rites[1], ':=');\n    if (this['void'] || !o.level) {\n      return Parens(Binary('||', test, put)).compile(o);\n    }\n    ref$ = test.first.cache(o, true), test.first = ref$[0], left = ref$[1];\n    return sn(this, If(test, left).addElse(put).compileExpression(o));\n  };\n  Assign.prototype.compileDestructuring = function(o, left){\n    var items, len, ret, rite, that, cache, rref, destructureArgs, list, code, sep, i$, len$, item;\n    items = left.items, len = items.length;\n    ret = o.level && !this['void'];\n    rite = this.right.compile(o, len === 1 ? LEVEL_CALL : LEVEL_LIST);\n    if (that = left.name) {\n      cache = sn(this, that, \" = \", rite);\n      o.scope.declare(rite = that, left);\n    } else if ((ret || len > 1) && (!ID.test(rite.toString()) || left.assigns(rite.toString()))) {\n      cache = sn(this, rref = o.scope.temporary(), \" = \", rite);\n      rite = rref;\n    }\n    if (rite.toString() === 'arguments' && !ret) {\n      destructureArgs = true;\n      if (!(left instanceof Arr)) {\n        this.carp('arguments can only destructure to array');\n      }\n    }\n    list = this[\"rend\" + left.constructor.displayName](o, items, rite, destructureArgs);\n    if (rref) {\n      o.scope.free(rref);\n    }\n    if (cache) {\n      list.unshift(cache);\n    }\n    if (ret || !list.length) {\n      list.push(rite);\n    }\n    code = [];\n    sep = destructureArgs ? '; ' : ', ';\n    for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {\n      item = list[i$];\n      code.push(item, sep);\n    }\n    code.pop();\n    if (list.length < 2 || o.level < LEVEL_LIST) {\n      return sn.apply(null, [this].concat(slice$.call(code)));\n    } else {\n      return sn.apply(null, [this, \"(\"].concat(slice$.call(code), [\")\"]));\n    }\n  };\n  Assign.prototype.compileSplice = function(o){\n    var ref$, fromExpNode, fromExp, rightNode, right, toExp;\n    ref$ = Chain(this.left.from).cacheReference(o), fromExpNode = ref$[0], fromExp = ref$[1];\n    ref$ = Chain(this.right).cacheReference(o), rightNode = ref$[0], right = ref$[1];\n    toExp = Binary('-', this.left.to, fromExp);\n    return sn(this, Block([Chain(Var(util('splice'))).add(Index(Key('apply'), '.', true)).add(Call([this.left.target, Chain(Arr([fromExpNode, toExp])).add(Index(Key('concat'), '.', true)).add(Call([rightNode]))])), right]).compile(o, LEVEL_LIST));\n  };\n  Assign.prototype.compileSpread = function(o, left){\n    var that, ref$, rite, rref, this$ = this;\n    ref$ = (that = this.unaries)\n      ? [that, that]\n      : left.items.length <= 1\n        ? [ref$ = this.right, ref$]\n        : this.right.cache(o, true), rite = ref$[0], rref = ref$[1];\n    return this.compileSpreadOver(o, left, function(it){\n      var result;\n      result = constructor(it, rite, this$.op, this$.logic);\n      rite = rref;\n      return result;\n    });\n  };\n  Assign.prototype.rendArr = function(o, nodes, rite, destructureArgs){\n    var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$, this$ = this;\n    function argsSlice(begin, end){\n      return new For({\n        ref: true,\n        from: begin,\n        op: 'til',\n        to: end\n      }).makeComprehension(Chain(Var('arguments')).add(Index(Literal('..'))), []);\n    }\n    ret = [];\n    for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {\n      i = i$;\n      node = nodes[i$];\n      if (node.isEmpty()) {\n        continue;\n      }\n      if (node instanceof Splat) {\n        len && node.carp('multiple splat in an assignment');\n        skip = (node = node.it).isEmpty();\n        if (i + 1 === (len = nodes.length)) {\n          if (skip) {\n            break;\n          }\n          if (destructureArgs) {\n            val = argsSlice(Literal(i), Chain(Var('arguments')).add(Index(Key('length'))));\n          } else {\n            val = Arr.wrap(JS(util('slice') + '.call(' + rite + (i ? \", \" + i + \")\" : ')')));\n          }\n        } else {\n          val = ivar = rite + \".length - \" + (len - i - 1);\n          if (skip && i + 2 === len) {\n            continue;\n          }\n          start = i + 1;\n          (this.temps || (this.temps = [])).push(ivar = o.scope.temporary('i'));\n          val = (fn$());\n        }\n      } else {\n        (inc = ivar) && start < i && (inc += \" + \" + (i - start));\n        val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);\n      }\n      if (node instanceof Assign) {\n        node = Binary(node.op, node.left, node.right, node.logic || true);\n      }\n      if (destructureArgs) {\n        if (!(node instanceof Var) && val instanceof For) {\n          (this.temps || (this.temps = [])).push(tmp = o.scope.temporary('ref'));\n          vtmp = Var(tmp);\n          ret.push((ref$ = clone$(this), ref$.left = vtmp, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));\n          ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = vtmp, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));\n        } else {\n          ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));\n        }\n      } else {\n        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));\n      }\n    }\n    return ret;\n    function fn$(){\n      switch (false) {\n      case !skip:\n        return Arr.wrap(JS(i + \" < (\" + ivar + \" = \" + val + \") ? \" + i + \" : (\" + ivar + \" = \" + i + \")\"));\n      case !destructureArgs:\n        return argsSlice(JS(i + \" < (\" + ivar + \" = \" + val + \") ? \" + i + \" : (\" + ivar + \" = \" + i + \")\"), Var(ivar));\n      default:\n        return Arr.wrap(JS(i + \" < (\" + ivar + \" = \" + val + \")\\ ? \" + util('slice') + \".call(\" + rite + \", \" + i + \", \" + ivar + \")\\ : (\" + ivar + \" = \" + i + \", [])\"));\n      }\n    }\n  };\n  Assign.prototype.rendObj = function(o, nodes, rite){\n    var i$, len$, node, splat, logic, ref$, key, val, rcache, results$ = [];\n    for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {\n      node = nodes[i$];\n      if (splat = node instanceof Splat) {\n        node = node.it;\n      }\n      if (logic = node.getDefault()) {\n        node = node.first;\n      }\n      if (node instanceof Parens) {\n        ref$ = Chain(node.it).cacheReference(o), node = ref$[0], key = ref$[1];\n      } else if (node instanceof Prop) {\n        node = (key = node.key, node).val;\n      } else {\n        key = node;\n      }\n      if (node instanceof Key) {\n        node = CopyL(node, Var(node.name));\n      }\n      if (logic) {\n        node = (logic.first = node, logic);\n      }\n      val = Chain(rcache || (rcache = Var(rite)), [Index(key.maybeKey())]);\n      if (splat) {\n        val = Import(Obj(), val);\n      }\n      results$.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));\n    }\n    return results$;\n  };\n  return Assign;\n}(Node));\nexports.Import = Import = (function(superclass){\n  var prototype = extend$((import$(Import, superclass).displayName = 'Import', Import), superclass).prototype, constructor = Import;\n  function Import(left, right, all){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.left = left;\n    this$.right = right;\n    this$.all = all && 'All';\n    if (!all && left instanceof Obj && right.items) {\n      return Obj(left.items.concat(right.asObj().items));\n    }\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Import.prototype.children = ['left', 'right'];\n  Import.prototype.show = function(){\n    return this.all;\n  };\n  prototype.delegate(['isCallable', 'isArray'], function(it){\n    return this.left[it]();\n  });\n  Import.prototype.unfoldSoak = function(o){\n    var left, value, ref$, temps;\n    left = this.left;\n    if (left instanceof Existence && !left.negated) {\n      if ((left = left.it) instanceof Var) {\n        value = (this.left = left).value;\n        if (!o.scope.check(value, true)) {\n          left = JS(\"typeof \" + value + \" != 'undefined' && \" + value);\n        }\n      } else {\n        ref$ = left.cache(o), left = ref$[0], this.left = ref$[1], temps = ref$[2];\n      }\n      return ref$ = If(left, this), ref$.temps = temps, ref$.soak = true, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;\n    }\n    return If.unfoldSoak(o, this, 'left') || (this['void'] || !o.level) && If.unfoldSoak(o, this, 'right');\n  };\n  Import.prototype.compileNode = function(o){\n    var right;\n    right = this.right;\n    if (!this.all) {\n      if (right instanceof Chain) {\n        right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();\n      }\n      if (right instanceof List) {\n        return this.compileAssign(o, right.asObj().items);\n      }\n    }\n    return CopyL(this, Call.make(Util(\"import\" + (this.all || '')), [this.left, right])).compileNode(o);\n  };\n  Import.prototype.compileAssign = function(o, items){\n    var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;\n    if (!items.length) {\n      return this.left.compile(o);\n    }\n    top = !o.level;\n    if (this.proto || (items.length < 2 && (top || this['void'] || items[0] instanceof Splat))) {\n      reft = this.left;\n      if (reft.isComplex()) {\n        reft = Parens(reft);\n      }\n    } else {\n      ref$ = this.left.cache(o), left = ref$[0], reft = ref$[1], this.temps = ref$[2];\n    }\n    ref$ = top\n      ? [';', '\\n' + this.tab]\n      : [',', ' '], delim = ref$[0], space = ref$[1];\n    delim += space;\n    code = this.temps\n      ? [left.compile(o, LEVEL_PAREN), delim]\n      : [];\n    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {\n      i = i$;\n      node = items[i$];\n      i && code.push(com ? space : delim);\n      if (com = node.comment) {\n        code.push(node.compile(o));\n        continue;\n      }\n      if (node instanceof Splat) {\n        code.push(Import(reft, node.it).compile(o));\n        continue;\n      }\n      if (logic = node.getDefault()) {\n        node = node.first;\n      }\n      if (dyna = node instanceof Parens) {\n        ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];\n      } else if (node instanceof Prop) {\n        key = node.key, val = node.val;\n        if (node.accessor) {\n          if (key instanceof Key) {\n            key = JS(\"'\" + key.name + \"'\");\n          }\n          code.push(\"Object.defineProperty(\", reft.compile(o, LEVEL_LIST), \", \", key.compile(o, LEVEL_LIST), \", \", node.compileDescriptor(o), \")\");\n          continue;\n        }\n      } else {\n        key = val = node;\n      }\n      dyna || (key = key.maybeKey());\n      logic && (val = (logic.first = val, logic));\n      code.push(Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN));\n    }\n    if (top) {\n      return sn.apply(null, [null].concat(slice$.call(code)));\n    }\n    this['void'] || node instanceof Splat || code.push(com ? ' ' : ', ', reft.compile(o, LEVEL_PAREN));\n    if (o.level < LEVEL_LIST) {\n      return sn.apply(null, [null].concat(slice$.call(code)));\n    } else {\n      return sn.apply(null, [null, \"(\"].concat(slice$.call(code), [\")\"]));\n    }\n  };\n  return Import;\n}(Node));\nexports.In = In = (function(superclass){\n  var prototype = extend$((import$(In, superclass).displayName = 'In', In), superclass).prototype, constructor = In;\n  importAll$(prototype, arguments[1]);\n  function In(item, array){\n    this.item = item;\n    this.array = array;\n  }\n  In.prototype.children = ['item', 'array'];\n  In.prototype.compileNode = function(o){\n    var array, items, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;\n    items = (array = this.array.expandSlice(o).unwrap()).items;\n    if (!(array instanceof Arr) || items.length < 2) {\n      return sn(this, this.negated ? '!' : '', util('in'), \"(\", this.item.compile(o, LEVEL_LIST), \", \", array.compile(o, LEVEL_LIST), \")\");\n    }\n    code = [];\n    ref$ = this.item.cache(o, false, LEVEL_PAREN), sub = ref$[0], ref = ref$[1];\n    ref$ = this.negated\n      ? [' !== ', ' && ']\n      : [' === ', ' || '], cmp = ref$[0], cnj = ref$[1];\n    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {\n      i = i$;\n      test = items[i$];\n      if (code.length > 0) {\n        code.push(cnj);\n      }\n      if (test instanceof Splat) {\n        code.push((ref$ = new In(Var(ref), test.it), ref$.negated = this.negated, ref$).compile(o, LEVEL_TOP));\n        if (!(i || sub === ref)) {\n          code = [\"(\" + sub + \", \"].concat(slice$.call(code), [\")\"]);\n        }\n      } else {\n        code.push(i || sub === ref\n          ? ref\n          : \"(\" + sub + \")\", cmp, test.compile(o, LEVEL_OP + PREC['==']));\n      }\n    }\n    sub === ref || o.scope.free(ref);\n    if (o.level < LEVEL_OP + PREC['||']) {\n      return sn.apply(null, [this].concat(slice$.call(code)));\n    } else {\n      return sn.apply(null, [this, \"(\"].concat(slice$.call(code), [\")\"]));\n    }\n  };\n  return In;\n}(Node, Negatable));\nexports.Existence = Existence = (function(superclass){\n  var prototype = extend$((import$(Existence, superclass).displayName = 'Existence', Existence), superclass).prototype, constructor = Existence;\n  importAll$(prototype, arguments[1]);\n  function Existence(it, negated){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.it = it;\n    this$.negated = negated;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Existence.prototype.children = ['it'];\n  Existence.prototype.compileNode = function(o){\n    var node, ref$, code, op, eq;\n    node = (ref$ = this.it.unwrap(), ref$.front = this.front, ref$);\n    code = [node.compile(o, LEVEL_OP + PREC['=='])];\n    if (node instanceof Var && !o.scope.check(code.join(\"\"), true)) {\n      ref$ = this.negated\n        ? ['||', '=']\n        : ['&&', '!'], op = ref$[0], eq = ref$[1];\n      code = [\"typeof \"].concat(slice$.call(code), [\" \" + eq + \"= 'undefined' \" + op + \" \"], slice$.call(code), [\" \" + eq + \"== null\"]);\n    } else {\n      code.push(\" \" + (op = this.negated ? '==' : '!=') + \" null\");\n    }\n    if (o.level < LEVEL_OP + PREC[op]) {\n      return sn.apply(null, [this].concat(slice$.call(code)));\n    } else {\n      return sn(this, \"(\", code, \")\");\n    }\n  };\n  return Existence;\n}(Node, Negatable));\nexports.Fun = Fun = (function(superclass){\n  var prototype = extend$((import$(Fun, superclass).displayName = 'Fun', Fun), superclass).prototype, constructor = Fun;\n  function Fun(params, body, bound, curried, hushed, generator){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.params = params || [];\n    this$.body = body || Block();\n    this$.bound = bound && 'this$';\n    this$.curried = curried || false;\n    this$.hushed = hushed != null ? hushed : false;\n    this$.generator = generator != null ? generator : false;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Fun.prototype.children = ['params', 'body'];\n  Fun.prototype.show = function(){\n    var that;\n    return [this.name] + [(that = this.bound) ? \"~\" + that : void 8];\n  };\n  Fun.prototype.named = function(it){\n    return this.name = it, this.statement = true, this;\n  };\n  Fun.prototype.isCallable = YES;\n  Fun.prototype.isStatement = function(){\n    return !!this.statement;\n  };\n  Fun.prototype.traverseChildren = function(arg$, xscope){\n    if (xscope) {\n      return superclass.prototype.traverseChildren.apply(this, arguments);\n    }\n  };\n  Fun.prototype.makeReturn = function(){\n    if (this.statement) {\n      return this.returns = true, this;\n    } else {\n      return superclass.prototype.makeReturn.apply(this, arguments);\n    }\n  };\n  Fun.prototype.ripName = function(it){\n    this.name || (this.name = it.varName());\n  };\n  Fun.prototype.compileNode = function(o){\n    var pscope, sscope, scope, that, inLoop, ref$, body, name, tab, code, bodyCode, curryCodeCheck, this$ = this;\n    pscope = o.scope;\n    sscope = pscope.shared || pscope;\n    scope = o.scope = this.body.scope = new Scope(this.wrapper ? pscope : sscope, this.wrapper && sscope);\n    scope.fun = this;\n    if (that = this.proto) {\n      scope.assign('prototype', that.compile(o) + \".prototype\");\n    }\n    if (that = this.cname) {\n      scope.assign('constructor', that);\n    }\n    if (inLoop = (ref$ = o.loop, delete o.loop, ref$)) {\n      o.indent = this.tab = '';\n    }\n    o.indent += TAB;\n    body = this.body, name = this.name, tab = this.tab;\n    code = ['function'];\n    if (this.generator) {\n      this.ctor && this.carp(\"a constructor can't be a generator\");\n      o.inGenerator = true;\n      code.push('*');\n    } else if (!this.wrapper) {\n      o.inGenerator = false;\n    }\n    if (this.bound === 'this$') {\n      if (this.ctor) {\n        scope.assign('this$', 'this instanceof ctor$ ? this : new ctor$');\n        body.lines.push(Return(Literal('this$')));\n      } else if (that = (ref$ = sscope.fun) != null ? ref$.bound : void 8) {\n        this.bound = that;\n      } else {\n        sscope.assign('this$', 'this');\n      }\n    }\n    if (this.statement) {\n      name || this.carp('nameless function declaration');\n      pscope === o.block.scope || this.carp('misplaced function declaration');\n      this.accessor && this.carp('named accessor');\n      pscope.add(name, 'function', this);\n    }\n    if (this.statement || name && this.labeled) {\n      code.push(' ', scope.add(name, 'function', this));\n    }\n    this.hushed || this.ctor || this.newed || body.makeReturn();\n    code.push(\"(\", this.compileParams(o, scope), \")\");\n    code = [sn.apply(null, [this].concat(slice$.call(code)))];\n    code.push(\"{\");\n    if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {\n      code.push(\"\\n\", bodyCode, \"\\n\" + tab);\n    }\n    code.push('}');\n    curryCodeCheck = function(){\n      if (this$.curried && this$.hasSplats) {\n        this$.carp('cannot curry a function with a variable number of arguments');\n      }\n      if (this$.curried && this$.params.length > 1 && !this$.classBound) {\n        if (this$.bound) {\n          return [util('curry'), \"((\"].concat(slice$.call(code), [\"), true)\"]);\n        } else {\n          return [util('curry'), \"(\"].concat(slice$.call(code), [\")\"]);\n        }\n      } else {\n        return code;\n      }\n    };\n    if (inLoop) {\n      return pscope.assign(pscope.temporary('fn'), sn.apply(null, [null].concat(slice$.call(curryCodeCheck()))));\n    }\n    if (this.returns) {\n      code.push(\"\\n\" + tab + \"return \", name, \";\");\n    } else if (this.bound && this.ctor) {\n      code.push(' function ctor$(){} ctor$.prototype = prototype;');\n    }\n    code = curryCodeCheck();\n    if (this.front && !this.statement) {\n      return sn.apply(null, [null, \"(\"].concat(slice$.call(code), [\")\"]));\n    } else {\n      return sn.apply(null, [null].concat(slice$.call(code)));\n    }\n  };\n  Fun.prototype.compileParams = function(o, scope){\n    var params, length, body, i$, p, len$, i, splace, rest, that, names, assigns, vr, df, unaries, hasUnary, v, ref$, ref1$;\n    params = this.params, length = params.length, body = this.body;\n    for (i$ = params.length - 1; i$ >= 0; --i$) {\n      p = params[i$];\n      if (!(p.isEmpty() || p.filler)) {\n        break;\n      }\n      --params.length;\n    }\n    for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {\n      i = i$;\n      p = params[i$];\n      if (p.left instanceof Splat) {\n        p.carp('invalid splat');\n      }\n      if (p instanceof Splat) {\n        this.hasSplats = true;\n        splace = i;\n      } else if (p.op === '=') {\n        params[i] = Binary(p.logic || '?', p.left, p.right);\n      }\n    }\n    if (splace != null) {\n      rest = params.splice(splace, 9e9);\n    } else if (this.accessor) {\n      if (that = params[1]) {\n        that.carp('excess accessor parameter');\n      }\n    } else if (!(length || this.wrapper)) {\n      if (body.traverseChildren(function(it){\n        return it.value === 'it' || null;\n      })) {\n        params[0] = Var('it');\n      }\n    }\n    names = [];\n    assigns = [];\n    for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {\n      p = params[i$];\n      vr = p;\n      if (df = vr.getDefault()) {\n        vr = vr.first;\n      }\n      if (vr.isEmpty()) {\n        vr = Var(scope.temporary('arg'));\n      } else if (vr.value === '..') {\n        vr = Var(o.ref = scope.temporary());\n      } else if (!(vr instanceof Var)) {\n        unaries = [];\n        while (vr instanceof Unary) {\n          hasUnary = true;\n          unaries.push(vr);\n          vr = vr.it;\n        }\n        v = Var((ref1$ = (ref$ = vr.it || vr).name, delete ref$.name, ref1$) || vr.varName() || scope.temporary('arg'));\n        assigns.push(Assign(vr, (fn$())));\n        vr = v;\n      } else if (df) {\n        assigns.push(Assign(vr, p.second, '=', p.op, true));\n      }\n      names.push(scope.add(vr.value, 'arg', p), ', ');\n    }\n    if (rest) {\n      while (splace--) {\n        rest.unshift(Arr());\n      }\n      assigns.push(Assign(Arr(rest), Literal('arguments')));\n    }\n    if (assigns.length) {\n      (ref$ = this.body).prepend.apply(ref$, assigns);\n    }\n    names.pop();\n    return sn.apply(null, [null].concat(slice$.call(names)));\n    function fn$(){\n      switch (false) {\n      case !df:\n        return Binary(p.op, v, p.second);\n      case !hasUnary:\n        return fold(function(x, y){\n          y.it = x;\n          return y;\n        }, v, unaries.reverse());\n      default:\n        return v;\n      }\n    }\n  };\n  return Fun;\n}(Node));\nexports.Class = Class = (function(superclass){\n  var prototype = extend$((import$(Class, superclass).displayName = 'Class', Class), superclass).prototype, constructor = Class;\n  function Class(arg$){\n    var body;\n    this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;\n    this.fun = Fun([], body);\n  }\n  Class.prototype.children = ['title', 'sup', 'mixins', 'fun'];\n  Class.prototype.isCallable = YES;\n  Class.prototype.ripName = function(it){\n    this.name = it.varName();\n  };\n  Class.prototype.compile = function(o, level){\n    var fun, body, lines, title, boundFuncs, curriedBoundFuncs, decl, name, proto, vname, ctorName, ctor, ctorPlace, importProtoObj, i$, len$, i, node, f, args, that, imports, ref$, res$, clas;\n    fun = this.fun, body = fun.body, lines = body.lines, title = this.title;\n    CopyL(this, fun);\n    boundFuncs = [];\n    curriedBoundFuncs = [];\n    decl = title != null ? title.varName() : void 8;\n    name = decl || this.name;\n    if (ID.test(name || '')) {\n      fun.cname = name;\n    } else {\n      name = 'constructor';\n    }\n    proto = Var('prototype');\n    vname = fun.proto = Var(fun.bound = name);\n    ctorName = 'constructor$$';\n    importProtoObj = function(node, i){\n      var j, prop, key, i$, ref$, len$, v;\n      j = 0;\n      for (; j < node.items.length; j++) {\n        prop = node.items[j];\n        key = prop.key;\n        if ((key instanceof Key && key.name === ctorName) || (key instanceof Literal && key.value === \"'\" + ctorName + \"'\")) {\n          if (ctor) {\n            node.carp('redundant constructor');\n          }\n          ctor = prop.val;\n          node.items.splice(j--, 1);\n          ctorPlace = i;\n        }\n        if (!(prop.val instanceof Fun || prop.accessor)) {\n          continue;\n        }\n        if (key.isComplex()) {\n          key = Var(o.scope.temporary('key'));\n          prop.key = Assign(key, prop.key);\n        }\n        if (prop.val.bound) {\n          if (prop.val.curried) {\n            curriedBoundFuncs.push(prop.key);\n          } else {\n            boundFuncs.push(prop.key);\n          }\n          prop.val.bound = false;\n          prop.val.classBound = true;\n        }\n        for (i$ = 0, len$ = (ref$ = [].concat(prop.val)).length; i$ < len$; ++i$) {\n          v = ref$[i$];\n          v.meth = key;\n        }\n      }\n      if (node.items.length) {\n        return ref$ = Import(Chain(vname).add(Index(Key('prototype'))), node), ref$.proto = true, ref$;\n      } else {\n        return Literal('void');\n      }\n    };\n    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {\n      i = i$;\n      node = lines[i$];\n      if (node instanceof Obj) {\n        lines[i] = importProtoObj(node, i);\n      } else if (node instanceof Fun && !node.statement) {\n        ctor && node.carp('redundant constructor');\n        ctor = node;\n      } else if (node instanceof Assign && node.left instanceof Chain && node.left.head.value === 'this' && node.right instanceof Fun) {\n        node.right.stat = node.left.tails[0].key;\n      } else {\n        node.traverseChildren(fn$);\n      }\n    }\n    ctor || (ctor = lines[lines.length] = this.sup\n      ? Fun([], Block(Chain(new Super).add(Call([Splat(Literal('arguments'))]))))\n      : Fun());\n    if (!(ctor instanceof Fun)) {\n      lines.splice(ctorPlace + 1, 0, Assign(Var(ctorName), ctor));\n      lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat('arguments', true)]))))));\n    }\n    ctor.name = name;\n    ctor.ctor = true;\n    ctor.statement = true;\n    for (i$ = 0, len$ = boundFuncs.length; i$ < len$; ++i$) {\n      f = boundFuncs[i$];\n      ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal(\"'\" + f.name + \"'\"), Var('prototype')]))));\n    }\n    for (i$ = 0, len$ = curriedBoundFuncs.length; i$ < len$; ++i$) {\n      f = curriedBoundFuncs[i$];\n      ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(Key(\"_\" + f.name))), Chain(Var(util('curry'))).add(Call([Chain(Var('prototype')).add(Index(f)), Var('true')]))), Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal(\"'_\" + f.name + \"'\")]))));\n    }\n    lines.push(vname);\n    args = [];\n    if (that = this.sup) {\n      args.push(that);\n      imports = Chain(Import(Literal('this'), Var('superclass')));\n      fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key('displayName'))), Literal(\"'\" + name + \"'\")), Literal(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var('superclass'));\n    }\n    if (that = this.mixins) {\n      res$ = [];\n      for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {\n        args[args.length] = that[i$];\n        res$.push(Import(proto, JS(\"arguments[\" + (args.length - 1) + \"]\"), true));\n      }\n      imports = res$;\n      body.prepend.apply(body, imports);\n    }\n    if (fun.cname && !this.sup) {\n      body.prepend(Literal(name + \".displayName = '\" + name + \"'\"));\n    }\n    clas = Parens(Call.make(fun, args), true);\n    if (decl && title.isComplex()) {\n      clas = Assign(vname, clas);\n    }\n    if (title) {\n      clas = Assign(title, clas);\n    }\n    return sn(null, clas.compile(o, level));\n    function fn$(it){\n      var i$, ref$, len$, k, child;\n      if (it instanceof Block) {\n        for (i$ = 0, len$ = (ref$ = it.lines).length; i$ < len$; ++i$) {\n          k = i$;\n          child = ref$[i$];\n          if (child instanceof Obj) {\n            it.lines[k] = importProtoObj(child, i);\n          }\n        }\n      }\n    }\n  };\n  return Class;\n}(Node));\nexports.Super = Super = (function(superclass){\n  var prototype = extend$((import$(Super, superclass).displayName = 'Super', Super), superclass).prototype, constructor = Super;\n  function Super(){}\n  Super.prototype.isCallable = YES;\n  Super.prototype.compile = function(o){\n    var scope, that, result, ref$;\n    scope = o.scope;\n    if (!this.sproto) {\n      for (; that = !scope.get('superclass') && scope.fun; scope = scope.parent) {\n        result = that;\n        if (that = result.meth) {\n          return sn(this, 'superclass.prototype', Index(that).compile(o));\n        }\n        if (that = result.stat) {\n          return sn(this, 'superclass', Index(that).compile(o));\n        }\n        if (that = scope.fun.inClass) {\n          return sn(this, that, \".superclass.prototype.\", scope.fun.name);\n        } else if (that = scope.fun.inClassStatic) {\n          return sn(this, that, \".superclass.\", scope.fun.name);\n        }\n      }\n      if (that = (ref$ = o.scope.fun) != null ? ref$.name : void 8) {\n        return sn(this, that, \".superclass\");\n      }\n    }\n    return sn(this, 'superclass');\n  };\n  return Super;\n}(Node));\nexports.Parens = Parens = (function(superclass){\n  var prototype = extend$((import$(Parens, superclass).displayName = 'Parens', Parens), superclass).prototype, constructor = Parens;\n  function Parens(it, keep, string, lb, rb){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.it = it;\n    this$.keep = keep;\n    this$.string = string;\n    this$.lb = lb;\n    this$.rb = rb;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Parens.prototype.children = ['it'];\n  Parens.prototype.show = function(){\n    return this.string && '\"\"';\n  };\n  prototype.delegate(['isComplex', 'isCallable', 'isArray', 'isRegex'], function(it){\n    return this.it[it]();\n  });\n  Parens.prototype.isString = function(){\n    return this.string || this.it.isString();\n  };\n  Parens.prototype.unparen = function(){\n    if (this.keep) {\n      return this;\n    } else {\n      return this.it.unparen();\n    }\n  };\n  Parens.prototype.compile = function(o, level){\n    var it;\n    level == null && (level = o.level);\n    it = this.it;\n    it.cond || (it.cond = this.cond), it['void'] || (it['void'] = this['void']);\n    if (this.calling && (!level || this['void'])) {\n      it.head.hushed = true;\n    }\n    if (!(this.keep || this.newed || level >= LEVEL_OP + PREC[it.op])) {\n      return (it.front = this.front, it).compile(o, level || LEVEL_PAREN);\n    }\n    if (it.isStatement()) {\n      return it.compileClosure(o);\n    } else {\n      return sn(null, sn(this.lb, \"(\"), it.compile(o, LEVEL_PAREN), sn(this.rb, \")\"));\n    }\n  };\n  return Parens;\n}(Node));\nexports.Splat = Splat = (function(superclass){\n  var ref$, prototype = extend$((import$(Splat, superclass).displayName = 'Splat', Splat), superclass).prototype, constructor = Splat;\n  function Splat(it, filler){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.it = it;\n    this$.filler = filler;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isComplex = ref$.isComplex;\n  Splat.prototype.isAssignable = YES;\n  Splat.prototype.assigns = function(it){\n    return this.it.assigns(it);\n  };\n  Splat.prototype.compile = function(){\n    return this.carp('invalid splat');\n  };\n  Splat.compileArray = function(o, list, apply){\n    var index, i$, len$, node, args, atoms, ref$;\n    expand(list);\n    index = 0;\n    for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {\n      node = list[i$];\n      if (node instanceof Splat) {\n        break;\n      }\n      ++index;\n    }\n    if (index >= list.length) {\n      return sn(this, '');\n    }\n    if (!list[1]) {\n      return sn(this, (apply ? Object : ensureArray)(list[0].it).compile(o, LEVEL_LIST));\n    }\n    args = [];\n    atoms = [];\n    for (i$ = 0, len$ = (ref$ = list.splice(index, 9e9)).length; i$ < len$; ++i$) {\n      node = ref$[i$];\n      if (node instanceof Splat) {\n        if (atoms.length) {\n          args.push(Arr(atoms.splice(0, 9e9)));\n        }\n        args.push(ensureArray(node.it));\n      } else {\n        atoms.push(node);\n      }\n    }\n    if (atoms.length) {\n      args.push(Arr(atoms));\n    }\n    return sn(null, (index\n      ? Arr(list)\n      : args.shift()).compile(o, LEVEL_CALL), sn(this, \".concat(\"), List.compile(o, args), sn(this, \")\"));\n  };\n  function expand(nodes){\n    var index, node, it;\n    index = -1;\n    while (node = nodes[++index]) {\n      if (node instanceof Splat) {\n        it = node.it;\n        if (it.isEmpty()) {\n          nodes.splice(index--, 1);\n        } else if (it instanceof Arr) {\n          nodes.splice.apply(nodes, [index, 1].concat(slice$.call(expand(it.items))));\n          index += it.items.length - 1;\n        }\n      }\n    }\n    return nodes;\n  }\n  function ensureArray(node){\n    if (node.isArray()) {\n      return node;\n    }\n    return Call.make(JS(util('slice') + '.call'), [node]);\n  }\n  return Splat;\n}(Node));\nexports.Jump = Jump = (function(superclass){\n  var prototype = extend$((import$(Jump, superclass).displayName = 'Jump', Jump), superclass).prototype, constructor = Jump;\n  function Jump(verb, label){\n    this.verb = verb;\n    this.label = label;\n  }\n  Jump.prototype.show = function(){\n    var that;\n    return (this.verb || '') + ((that = this.label) ? ' ' + that : '');\n  };\n  Jump.prototype.isStatement = YES;\n  Jump.prototype.makeReturn = THIS;\n  Jump.prototype.getJump = function(ctx){\n    var that, ref$;\n    ctx || (ctx = {});\n    if (!ctx[this.verb]) {\n      return this;\n    }\n    if (that = this.label) {\n      return !in$(that, (ref$ = ctx.labels) != null\n        ? ref$\n        : ctx.labels = []) && this;\n    }\n  };\n  Jump.prototype.compileNode = function(o){\n    var that, ref$;\n    if (that = this.label) {\n      in$(that, (ref$ = o.labels) != null\n        ? ref$\n        : o.labels = []) || this.carp(\"unknown label \\\"\" + that + \"\\\"\");\n    } else {\n      o[this.verb] || this.carp(\"stray \" + this.verb);\n    }\n    return sn(this, this.show() + ';');\n  };\n  Jump.extended = function(sub){\n    sub.prototype.children = ['it'];\n    this[sub.displayName.toLowerCase()] = sub;\n  };\n  return Jump;\n}(Node));\nexports.Throw = Throw = (function(superclass){\n  var prototype = extend$((import$(Throw, superclass).displayName = 'Throw', Throw), superclass).prototype, constructor = Throw;\n  function Throw(it){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.it = it;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Throw.prototype.getJump = VOID;\n  Throw.prototype.compileNode = function(o){\n    var ref$;\n    return sn(this, \"throw \", ((ref$ = this.it) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || 'null', \";\");\n  };\n  return Throw;\n}(Jump));\nexports.Return = Return = (function(superclass){\n  var prototype = extend$((import$(Return, superclass).displayName = 'Return', Return), superclass).prototype, constructor = Return;\n  function Return(it){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    if (it && it.value !== 'void') {\n      this$.it = it;\n    }\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Return.prototype.getJump = THIS;\n  Return.prototype.compileNode = function(o){\n    var that;\n    return sn.apply(null, [this, \"return\"].concat(\n      (that = this.it)\n        ? [' ', that.compile(o, LEVEL_PAREN)]\n        : [], [\";\"]\n    ));\n  };\n  return Return;\n}(Jump));\nexports.While = While = (function(superclass){\n  var prototype = extend$((import$(While, superclass).displayName = 'While', While), superclass).prototype, constructor = While;\n  function While(test, un, mode){\n    this.un = un;\n    mode && (mode instanceof Node\n      ? this.update = mode\n      : this.post = true);\n    if (this.post || test.value !== '' + !un) {\n      this.test = test;\n    }\n  }\n  While.prototype.children = ['test', 'body', 'update', 'else'];\n  While.prototype.aSource = 'test';\n  While.prototype.aTargets = ['body', 'update'];\n  While.prototype.show = function(){\n    return [this.un ? '!' : void 8, this.post ? 'do' : void 8].join('');\n  };\n  prototype.isStatement = prototype.isArray = YES;\n  While.prototype.makeComprehension = function(toAdd, loops){\n    this.isComprehension = true;\n    while (loops.length) {\n      toAdd = loops.pop().addBody(Block(toAdd));\n      if (!toAdd.isComprehension) {\n        toAdd.inComprehension = true;\n      }\n    }\n    return this.addBody(Block(toAdd));\n  };\n  While.prototype.getJump = function(ctx){\n    var i$, ref$, ref1$, len$, node;\n    ctx || (ctx = {});\n    ctx['continue'] = true;\n    ctx['break'] = true;\n    for (i$ = 0, len$ = (ref$ = ((ref1$ = this.body) != null ? ref1$.lines : void 8) || []).length; i$ < len$; ++i$) {\n      node = ref$[i$];\n      if (node.getJump(ctx)) {\n        return node;\n      }\n    }\n  };\n  While.prototype.addBody = function(body){\n    var top;\n    this.body = body;\n    if (this.guard) {\n      this.body = Block(If(this.guard, this.body));\n    }\n    top = this.body.lines[0];\n    if ((top != null ? top.verb : void 8) === 'continue' && !top.label) {\n      this.body.lines.length = 0;\n    }\n    return this;\n  };\n  While.prototype.addGuard = function(guard){\n    this.guard = guard;\n    return this;\n  };\n  While.prototype.addObjComp = function(objComp){\n    this.objComp = objComp != null ? objComp : true;\n    return this;\n  };\n  While.prototype.makeReturn = function(it){\n    var last, ref$, ref1$, ref2$;\n    if (this.hasReturned) {\n      return this;\n    }\n    if (it) {\n      if (this.objComp) {\n        this.body = Block(this.body.makeReturn(it, true));\n      } else {\n        if (!(this.body || this.index)) {\n          this.addBody(Block(Var(this.index = 'ridx$')));\n        }\n        last = (ref$ = this.body.lines) != null ? ref$[ref$.length - 1] : void 8;\n        if ((this.isComprehension || this.inComprehension) && !(last != null && last.isComprehension)) {\n          (ref1$ = this.body).makeReturn.apply(ref1$, arguments);\n          if ((ref1$ = this['else']) != null) {\n            ref1$.makeReturn.apply(ref1$, arguments);\n          }\n          this.hasReturned = true;\n        } else {\n          this.resVar = it;\n          if ((ref2$ = this['else']) != null) {\n            ref2$.makeReturn.apply(ref2$, arguments);\n          }\n        }\n      }\n    } else {\n      this.getJump() || (this.returns = true);\n    }\n    return this;\n  };\n  While.prototype.compileNode = function(o){\n    var test, ref$, head, that;\n    o.loop = true;\n    this.test && (this.un\n      ? this.test = this.test.invert()\n      : this.anaphorize());\n    if (this.post) {\n      return sn(null, sn(this, 'do {'), this.compileBody((o.indent += TAB, o)));\n    }\n    test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || '';\n    if (!(this.update || this['else'])) {\n      head = !snEmpty(test)\n        ? [sn(this, \"while (\"), test]\n        : [sn(this, 'for (;;')];\n    } else {\n      head = [sn(this, 'for (')];\n      if (this['else']) {\n        head.push(this.yet = o.scope.temporary('yet'), \" = true\");\n      }\n      head.push(sn(this, \";\"), test.toString() && ' ', test, sn(this, \";\"));\n      if (that = this.update) {\n        head.push(' ', that.compile(o, LEVEL_PAREN));\n      }\n    }\n    return sn.apply(null, [null].concat(slice$.call(head), [sn(this, ') {'), this.compileBody((o.indent += TAB, o))]));\n  };\n  While.prototype.compileBody = function(o){\n    var lines, yet, tab, code, ret, mid, empty, _resultName, getResultName, last, hasLoop, res, temp, key$, ref$, bodyCode, this$ = this;\n    o['break'] = o['continue'] = true;\n    lines = this.body.lines, yet = this.yet, tab = this.tab;\n    code = [];\n    ret = [];\n    mid = [];\n    empty = this.objComp ? '{}' : '[]';\n    getResultName = function(){\n      return _resultName != null\n        ? _resultName\n        : _resultName = o.scope.temporary(this$.objComp ? 'resultObj' : 'results');\n    };\n    last = lines != null ? lines[lines.length - 1] : void 8;\n    if (!(this.isComprehension || this.inComprehension) || (last != null && last.isComprehension)) {\n      hasLoop = false;\n      if (last != null) {\n        last.traverseChildren(function(it){\n          var ref$;\n          if (it instanceof Block && (ref$ = it.lines)[ref$.length - 1] instanceof While) {\n            hasLoop = true;\n          }\n        });\n      }\n      if (this.returns && !this.resVar) {\n        this.resVar = res = o.scope.assign(getResultName(), empty);\n      }\n      if (this.resVar && (last instanceof While || hasLoop)) {\n        temp = o.scope.temporary('lresult');\n        lines.unshift(Assign(Var(temp), lines[lines.length - 1].objComp\n          ? Obj()\n          : Arr(), '='));\n        if (lines[key$ = lines.length - 1] != null) {\n          lines[key$] = lines[key$].makeReturn(temp);\n        }\n        mid.push(TAB, Chain(Var(this.resVar)).add(Index(Key('push'), '.', true)).add(Call([Chain(Var(temp))])).compile(o), \";\\n\" + this.tab);\n      } else {\n        this.hasReturned = true;\n        if (this.resVar) {\n          this.body.makeReturn(this.resVar);\n        }\n      }\n    }\n    if (this.returns) {\n      if ((!last instanceof While && !this.hasReturned) || this.isComprehension || this.inComprehension) {\n        if (lines[key$ = lines.length - 1] != null) {\n          lines[key$] = lines[key$].makeReturn(res = o.scope.assign(getResultName(), empty), this.objComp);\n        }\n      }\n      ret.push(\"\\n\" + this.tab + \"return \", res || empty, \";\");\n      if ((ref$ = this['else']) != null) {\n        ref$.makeReturn();\n      }\n    }\n    yet && lines.unshift(JS(yet + \" = false;\"));\n    if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {\n      code.push(\"\\n\", bodyCode, \"\\n\" + tab);\n    }\n    code.push.apply(code, mid);\n    code.push('}');\n    if (this.post) {\n      code.push(sn(this, \" while (\"), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, \");\"));\n    }\n    if (yet) {\n      code.push(sn(this, \" if (\"), yet, sn(this, \") \"), this.compileBlock(o, Block(this['else'])));\n      o.scope.free(yet);\n    }\n    return sn.apply(null, [null].concat(slice$.call(code), slice$.call(ret)));\n  };\n  return While;\n}(Node));\nexports.For = For = (function(superclass){\n  var prototype = extend$((import$(For, superclass).displayName = 'For', For), superclass).prototype, constructor = For;\n  function For(it){\n    var i$, x$, ref$, len$;\n    importAll$(this, it);\n    if (this.item instanceof Var && !this.item.value) {\n      this.item = null;\n    }\n    for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ < len$; ++i$) {\n      x$ = ref$[i$];\n      this[x$] = true;\n    }\n    if (this.own && !this.object) {\n      this.carp('`for own` requires `of`');\n    }\n  }\n  For.prototype.children = ['item', 'source', 'from', 'to', 'step', 'body'];\n  For.prototype.aSource = null;\n  For.prototype.show = function(){\n    return ((this.kind || []).concat(this.index)).join(' ');\n  };\n  For.prototype.addBody = function(body){\n    var hasYield, ref$, x$, that, this$ = this;\n    hasYield = !!body.traverseChildren(function(child){\n      if (child instanceof Yield) {\n        return true;\n      }\n    });\n    if (this['let']) {\n      if (ref$ = this.ref, delete this.ref, ref$) {\n        this.item = Literal('..');\n      }\n      body = Block(Call['let']((x$ = [], (that = this.index) && x$.push(Assign(Var(that), Literal('index$$'))), (that = this.item) && x$.push(Assign(that, Literal('item$$'))), x$), body, hasYield));\n    }\n    superclass.prototype.addBody.call(this, body);\n    if (this.guard && this['let'] && (this.index || this.item)) {\n      this.body.lines[0]['if'].traverseChildren(function(it){\n        if (it instanceof Var) {\n          if (this$.index && it.value === this$.index) {\n            it.value = 'index$$';\n          }\n          if (this$.item && it.value === this$.item.value) {\n            it.value = 'item$$';\n          }\n        }\n      });\n    }\n    if (this['let']) {\n      if (hasYield) {\n        this.body = Block(Yield('yieldfrom', body));\n      }\n      delete this.index;\n      delete this.item;\n    }\n    return this;\n  };\n  For.prototype.compileNode = function(o){\n    var temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body;\n    o.loop = true;\n    temps = this.temps = [];\n    if (this.object && this.index) {\n      o.scope.declare(idx = this.index);\n    } else {\n      temps.push(idx = o.scope.temporary('i'));\n    }\n    if (!this.body) {\n      this.addBody(Block(Var(idx)));\n    }\n    if (!this.object) {\n      ref$ = (this.step || Literal(1)).compileLoopReference(o, 'step'), pvar = ref$[0], step = ref$[1];\n      pvar === step || temps.push(pvar);\n    }\n    if (this.from) {\n      if (this.ref) {\n        this.item = Var(idx);\n      }\n      ref$ = this.to.compileLoopReference(o, 'to'), tvar = ref$[0], tail = ref$[1];\n      fvar = this.from.compile(o, LEVEL_LIST);\n      vars = idx + \" = \" + fvar;\n      if (tail !== tvar) {\n        vars += \", \" + tail;\n        temps.push(tvar);\n      }\n      if (!this.step && +fvar > +tvar) {\n        pvar = step = -1;\n      }\n      eq = this.op === 'til' ? '' : '=';\n      cond = +pvar\n        ? idx + \" \" + '<>'.charAt(pvar < 0) + eq + \" \" + tvar\n        : pvar + \" < 0 ? \" + idx + \" >\" + eq + \" \" + tvar + \" : \" + idx + \" <\" + eq + \" \" + tvar;\n    } else {\n      if (this.ref) {\n        this.item = Var(o.scope.temporary('x'));\n      }\n      if (this.item || this.object && this.own || this['let']) {\n        ref$ = this.source.compileLoopReference(o, 'ref', !this.object, true), svar = ref$[0], srcPart = ref$[1];\n        svar === srcPart || temps.push(svar);\n      } else {\n        svar = srcPart = this.source.compile(o, LEVEL_PAREN);\n      }\n      if (!this.object) {\n        if (0 > pvar && ~~pvar === +pvar) {\n          vars = idx + \" = \" + srcPart + \".length - 1\";\n          cond = idx + \" >= 0\";\n        } else {\n          temps.push(lvar = o.scope.temporary('len'));\n          vars = idx + \" = 0, \" + lvar + \" = \" + srcPart + \".length\";\n          cond = idx + \" < \" + lvar;\n        }\n      }\n    }\n    this['else'] && (this.yet = o.scope.temporary('yet'));\n    head = [sn(this, 'for (')];\n    if (this.object) {\n      head.push(idx, \" in \");\n    }\n    if (that = this.yet) {\n      head.push(that, \" = true, \");\n    }\n    if (this.object) {\n      head.push(srcPart);\n    } else {\n      step === pvar || (vars += ', ' + step);\n      head.push(vars, \"; \", cond, \"; \" + (1 == Math.abs(pvar)\n        ? (pvar < 0 ? '--' : '++') + idx\n        : idx + (pvar < 0\n          ? ' -= ' + pvar.toString().slice(1)\n          : ' += ' + pvar)));\n    }\n    this.own && head.push(sn(this, \") if (\"), o.scope.assign('own$', '{}.hasOwnProperty'), \".call(\", svar, \", \", idx, \")\");\n    head.push(sn(this, ') {'));\n    if (this['let']) {\n      this.body.traverseChildren(function(it){\n        switch (it.value) {\n        case 'index$$':\n          it.value = idx;\n          break;\n        case 'item$$':\n          it.value = svar + \"[\" + idx + \"]\";\n        }\n      });\n    }\n    o.indent += TAB;\n    if (this.index && !this.object) {\n      head.push('\\n' + o.indent, Assign(Var(this.index), JS(idx)).compile(o, LEVEL_TOP), ';');\n    }\n    if (this.item && !this.item.isEmpty() && !this.from) {\n      head.push('\\n' + o.indent, Assign(this.item, JS(svar + \"[\" + idx + \"]\")).compile(o, LEVEL_TOP), ';');\n    }\n    if (this.ref) {\n      o.ref = this.item.value;\n    }\n    body = this.compileBody(o);\n    if ((this.item || (this.index && !this.object)) && '}' === body.toString().charAt(0)) {\n      head.push('\\n' + this.tab);\n    }\n    return sn.apply(null, [null].concat(slice$.call(head), [body]));\n  };\n  return For;\n}(While));\nexports.StepSlice = StepSlice = (function(superclass){\n  var prototype = extend$((import$(StepSlice, superclass).displayName = 'StepSlice', StepSlice), superclass).prototype, constructor = StepSlice;\n  StepSlice.prototype.makeReturn = function(makeReturnArg){\n    this.makeReturnArg = makeReturnArg;\n    return superclass.prototype.makeReturn.apply(this, arguments);\n  };\n  StepSlice.prototype.compileNode = function(o){\n    var ref$, sub, ref, temps, code;\n    this.index = o.scope.temporary('x');\n    ref$ = this.target.unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];\n    this.guard = Binary('<', Literal(this.index), Chain(ref).add(Index(Key('length'))));\n    this.makeComprehension(Chain(ref).add(Index(Literal(this.index))), this);\n    if (this.makeReturnArg != null) {\n      this.makeReturn(this.makeReturnArg);\n    }\n    code = [];\n    if (temps) {\n      code.push(sub.compile(o), ';' + '\\n' + o.indent);\n    }\n    code.push(superclass.prototype.compileNode.apply(this, arguments));\n    return sn.apply(null, [this].concat(slice$.call(code)));\n  };\n  function StepSlice(){\n    StepSlice.superclass.apply(this, arguments);\n  }\n  return StepSlice;\n}(For));\nexports.Try = Try = (function(superclass){\n  var prototype = extend$((import$(Try, superclass).displayName = 'Try', Try), superclass).prototype, constructor = Try;\n  function Try(attempt, thrown, recovery, ensure){\n    var ref$;\n    this.attempt = attempt;\n    this.thrown = thrown;\n    this.recovery = recovery;\n    this.ensure = ensure;\n    if ((ref$ = this.recovery) != null) {\n      ref$.lines.unshift(Assign(this.thrown || Var('e'), Var('e$')));\n    }\n  }\n  Try.prototype.children = ['attempt', 'recovery', 'ensure'];\n  Try.prototype.show = function(){\n    return this.thrown;\n  };\n  Try.prototype.isStatement = YES;\n  Try.prototype.isCallable = function(){\n    var ref$;\n    return ((ref$ = this.recovery) != null ? ref$.isCallable() : void 8) && this.attempt.isCallable();\n  };\n  Try.prototype.getJump = function(it){\n    var ref$;\n    return this.attempt.getJump(it) || ((ref$ = this.recovery) != null ? ref$.getJump(it) : void 8);\n  };\n  Try.prototype.makeReturn = function(){\n    var ref$;\n    this.attempt = (ref$ = this.attempt).makeReturn.apply(ref$, arguments);\n    if (this.recovery != null) {\n      this.recovery = (ref$ = this.recovery).makeReturn.apply(ref$, arguments);\n    }\n    return this;\n  };\n  Try.prototype.compileNode = function(o){\n    var code, that;\n    o.indent += TAB;\n    code = [sn(this, 'try '), this.compileBlock(o, this.attempt)];\n    if (that = this.recovery || !this.ensure && JS('')) {\n      code.push(sn(that, ' catch (e$) '), this.compileBlock(o, that));\n    }\n    if (that = this.ensure) {\n      code.push(sn(that, ' finally '), this.compileBlock(o, that));\n    }\n    return sn.apply(null, [null].concat(slice$.call(code)));\n  };\n  return Try;\n}(Node));\nexports.Switch = Switch = (function(superclass){\n  var prototype = extend$((import$(Switch, superclass).displayName = 'Switch', Switch), superclass).prototype, constructor = Switch;\n  function Switch(type, topic, cases, $default){\n    var last, ref$;\n    this.type = type;\n    this.topic = topic;\n    this.cases = cases;\n    this['default'] = $default;\n    if (type === 'match') {\n      if (topic) {\n        this.target = Arr(topic);\n      }\n      this.topic = null;\n    } else {\n      if (topic) {\n        if (topic.length > 1) {\n          throw \"can't have more than one topic in switch statement\";\n        }\n        this.topic = this.topic[0];\n      }\n    }\n    if (this.cases.length && (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 && last.tests[0] instanceof Var && last.tests[0].value === '_') {\n      this.cases.pop();\n      this['default'] = last.body;\n    }\n  }\n  Switch.prototype.children = ['topic', 'cases', 'default'];\n  Switch.prototype.aSource = 'topic';\n  Switch.prototype.aTargets = ['cases', 'default'];\n  Switch.prototype.show = function(){\n    return this.type;\n  };\n  Switch.prototype.isStatement = YES;\n  Switch.prototype.isCallable = function(){\n    var i$, ref$, len$, c;\n    for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {\n      c = ref$[i$];\n      if (!c.isCallable()) {\n        return false;\n      }\n    }\n    if (this['default']) {\n      return this['default'].isCallable();\n    } else {\n      return true;\n    }\n  };\n  Switch.prototype.getJump = function(ctx){\n    var i$, ref$, len$, c, that;\n    ctx || (ctx = {});\n    ctx['break'] = true;\n    for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {\n      c = ref$[i$];\n      if (that = c.body.getJump(ctx)) {\n        return that;\n      }\n    }\n    return (ref$ = this['default']) != null ? ref$.getJump(ctx) : void 8;\n  };\n  Switch.prototype.makeReturn = function(){\n    var i$, ref$, len$, c;\n    for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {\n      c = ref$[i$];\n      c.makeReturn.apply(c, arguments);\n    }\n    if ((ref$ = this['default']) != null) {\n      ref$.makeReturn.apply(ref$, arguments);\n    }\n    return this;\n  };\n  Switch.prototype.compileNode = function(o){\n    var tab, ref$, targetNode, target, topic, t, code, stop, i$, len$, i, c, that;\n    tab = this.tab;\n    if (this.target) {\n      ref$ = Chain(this.target).cacheReference(o), targetNode = ref$[0], target = ref$[1];\n    }\n    topic = this.type === 'match'\n      ? (t = target\n        ? [targetNode]\n        : [], Block(t.concat([Literal('false')])).compile(o, LEVEL_PAREN))\n      : !!this.topic && this.anaphorize().compile(o, LEVEL_PAREN);\n    code = [sn(this, \"switch (\", snSafe(topic), \") {\\n\")];\n    stop = this['default'] || this.cases.length - 1;\n    o['break'] = true;\n    for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {\n      i = i$;\n      c = ref$[i$];\n      code.push(c.compileCase(o, tab, i === stop, this.type === 'match' || !topic, this.type, target));\n    }\n    if (this['default']) {\n      o.indent = tab + TAB;\n      if (that = this['default'].compile(o, LEVEL_TOP)) {\n        code.push(tab + \"default:\\n\", that, \"\\n\");\n      }\n    }\n    return sn.apply(null, [null].concat(slice$.call(code), [tab + '}']));\n  };\n  return Switch;\n}(Node));\nexports.Case = Case = (function(superclass){\n  var prototype = extend$((import$(Case, superclass).displayName = 'Case', Case), superclass).prototype, constructor = Case;\n  function Case(tests, body){\n    this.tests = tests;\n    this.body = body;\n  }\n  Case.prototype.children = ['tests', 'body'];\n  Case.prototype.isCallable = function(){\n    return this.body.isCallable();\n  };\n  Case.prototype.makeReturn = function(){\n    var ref$, ref1$;\n    if (((ref$ = (ref1$ = this.body.lines)[ref1$.length - 1]) != null ? ref$.value : void 8) !== 'fallthrough') {\n      (ref1$ = this.body).makeReturn.apply(ref1$, arguments);\n    }\n    return this;\n  };\n  Case.prototype.compileCase = function(o, tab, nobr, bool, type, target){\n    var tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft, bodyCode;\n    tests = [];\n    for (i$ = 0, len$ = (ref$ = this.tests).length; i$ < len$; ++i$) {\n      test = ref$[i$];\n      test = test.expandSlice(o).unwrap();\n      if (test instanceof Arr && type !== 'match') {\n        for (j$ = 0, len1$ = (ref1$ = test.items).length; j$ < len1$; ++j$) {\n          t = ref1$[j$];\n          tests.push(t);\n        }\n      } else {\n        tests.push(test);\n      }\n    }\n    tests.length || tests.push(Literal('void'));\n    if (type === 'match') {\n      for (i$ = 0, len$ = tests.length; i$ < len$; ++i$) {\n        i = i$;\n        test = tests[i$];\n        tar = Chain(target).add(Index(Literal(i), '.', true));\n        tests[i] = Parens(Chain(test).autoCompare(target ? [tar] : null));\n      }\n    }\n    if (bool) {\n      binary = type === 'match' ? '&&' : '||';\n      t = tests[0];\n      i = 0;\n      while (that = tests[++i]) {\n        t = Binary(binary, t, that);\n      }\n      tests = [(this.t = t, this.aSource = 't', this.aTargets = ['body'], this).anaphorize().invert()];\n    }\n    code = [];\n    for (i$ = 0, len$ = tests.length; i$ < len$; ++i$) {\n      t = tests[i$];\n      code.push(tab, sn(t, \"case \", t.compile(o, LEVEL_PAREN), \":\\n\"));\n    }\n    lines = this.body.lines;\n    last = lines[lines.length - 1];\n    if (ft = (last != null ? last.value : void 8) === 'fallthrough') {\n      lines[lines.length - 1] = JS('// fallthrough');\n    }\n    o.indent = tab += TAB;\n    if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {\n      code.push(bodyCode, '\\n');\n    }\n    if (!(nobr || ft || last instanceof Jump)) {\n      code.push(tab + 'break;\\n');\n    }\n    return sn.apply(null, [null].concat(slice$.call(code)));\n  };\n  return Case;\n}(Node));\nexports.If = If = (function(superclass){\n  var prototype = extend$((import$(If, superclass).displayName = 'If', If), superclass).prototype, constructor = If;\n  function If($if, then, un){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$['if'] = $if;\n    this$.then = then;\n    this$.un = un;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  If.prototype.children = ['if', 'then', 'else'];\n  If.prototype.aSource = 'if';\n  If.prototype.aTargets = ['then'];\n  If.prototype.show = function(){\n    return this.un && '!';\n  };\n  If.prototype.terminator = '';\n  prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], function(it){\n    var ref$;\n    return ((ref$ = this['else']) != null ? ref$[it]() : void 8) && this.then[it]();\n  });\n  If.prototype.getJump = function(it){\n    var ref$;\n    return this.then.getJump(it) || ((ref$ = this['else']) != null ? ref$.getJump(it) : void 8);\n  };\n  If.prototype.makeReturn = function(){\n    var ref$;\n    this.then = (ref$ = this.then).makeReturn.apply(ref$, arguments);\n    if (this['else'] != null) {\n      this['else'] = (ref$ = this['else']).makeReturn.apply(ref$, arguments);\n    }\n    return this;\n  };\n  If.prototype.compileNode = function(o){\n    if (this.un) {\n      this['if'] = this['if'].invert();\n    } else {\n      this.soak || this.anaphorize();\n    }\n    if (o.level) {\n      return this.compileExpression(o);\n    } else {\n      return this.compileStatement(o);\n    }\n  };\n  If.prototype.compileStatement = function(o){\n    var code, els;\n    code = [sn(this, \"if (\", this['if'].compile(o, LEVEL_PAREN), \") \")];\n    o.indent += TAB;\n    code.push(this.compileBlock(o, Block(this.then)));\n    if (!(els = this['else'])) {\n      return sn.apply(null, [null].concat(slice$.call(code)));\n    }\n    return sn.apply(null, [null].concat(\n      slice$.call(code), [\n        sn(els, ' else '), els instanceof constructor\n          ? els.compile((o.indent = this.tab, o), LEVEL_TOP)\n          : this.compileBlock(o, els)\n      ]\n    ));\n  };\n  If.prototype.compileExpression = function(o){\n    var thn, els, code, pad;\n    thn = this.then, els = this['else'] || Literal('void');\n    this['void'] && (thn['void'] = els['void'] = true);\n    if (!this['else'] && (this.cond || this['void'])) {\n      return Parens(Binary('&&', this['if'], thn)).compile(o);\n    }\n    code = [sn(this, this['if'].compile(o, LEVEL_COND))];\n    pad = els.isComplex() ? '\\n' + (o.indent += TAB) : ' ';\n    code.push(pad + \"\", sn(thn, \"? \"), thn.compile(o, LEVEL_LIST), pad + \"\", sn(els, \": \"), els.compile(o, LEVEL_LIST));\n    if (o.level < LEVEL_COND) {\n      return sn.apply(null, [null].concat(slice$.call(code)));\n    } else {\n      return sn(null, \"(\", code, \")\");\n    }\n  };\n  If.unfoldSoak = function(o, parent, name){\n    var that;\n    if (that = parent[name].unfoldSoak(o)) {\n      parent[name] = that.then;\n      return that.cond = parent.cond, that['void'] = parent['void'], that.then = Chain(parent), that;\n    }\n  };\n  return If;\n}(Node));\nexports.Label = Label = (function(superclass){\n  var ref$, prototype = extend$((import$(Label, superclass).displayName = 'Label', Label), superclass).prototype, constructor = Label;\n  function Label(label, it){\n    var fun;\n    this.label = label || '_';\n    this.it = it;\n    if (fun = (it instanceof Fun || it instanceof Class) && it || it.calling && it.it.head) {\n      fun.name || (fun.name = this.label, fun.labeled = true);\n      return it;\n    }\n  }\n  ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isCallable = ref$.isCallable, prototype.isArray = ref$.isArray;\n  Label.prototype.show = function(){\n    return this.label;\n  };\n  Label.prototype.isStatement = YES;\n  Label.prototype.getJump = function(ctx){\n    var ref$;\n    ctx || (ctx = {});\n    ((ref$ = ctx.labels) != null\n      ? ref$\n      : ctx.labels = []).push(this.label);\n    return this.it.getJump((ctx['break'] = true, ctx));\n  };\n  Label.prototype.makeReturn = function(){\n    var ref$;\n    this.it = (ref$ = this.it).makeReturn.apply(ref$, arguments);\n    return this;\n  };\n  Label.prototype.compileNode = function(o){\n    var label, it, labels;\n    label = this.label, it = this.it;\n    labels = o.labels = slice$.call(o.labels || []);\n    if (in$(label, labels)) {\n      this.carp(\"duplicate label \\\"\" + label + \"\\\"\");\n    }\n    labels.push(label);\n    it.isStatement() || (it = Block(it));\n    return sn(null, sn(this, label, \": \"), it instanceof Block\n      ? (o.indent += TAB, this.compileBlock(o, it))\n      : it.compile(o));\n  };\n  return Label;\n}(Node));\nexports.Cascade = Cascade = (function(superclass){\n  var prototype = extend$((import$(Cascade, superclass).displayName = 'Cascade', Cascade), superclass).prototype, constructor = Cascade;\n  function Cascade(input, output, prog1){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.input = input;\n    this$.output = output;\n    this$.prog1 = prog1;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Cascade.prototype.show = function(){\n    return this.prog1;\n  };\n  Cascade.prototype.children = ['input', 'output'];\n  Cascade.prototype.terminator = '';\n  prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], function(it){\n    return this[this.prog1 ? 'input' : 'output'][it]();\n  });\n  Cascade.prototype.getJump = function(it){\n    return this.output.getJump(it);\n  };\n  Cascade.prototype.makeReturn = function(ret){\n    this.ret = ret;\n    return this;\n  };\n  Cascade.prototype.compileNode = function(o){\n    var level, input, output, prog1, ref, ref$, code, out;\n    level = o.level;\n    input = this.input, output = this.output, prog1 = this.prog1, ref = this.ref;\n    if (prog1 && ('ret' in this || level && !this['void'])) {\n      output.add((ref$ = Literal('..'), ref$.cascadee = true, ref$));\n    }\n    if ('ret' in this) {\n      output = output.makeReturn(this.ret);\n    }\n    if (ref) {\n      prog1 || (output = Assign(Var(ref), output));\n    } else {\n      ref = o.scope.temporary('x');\n    }\n    if (input instanceof Cascade) {\n      input.ref = ref;\n    } else {\n      input && (input = Assign(Var(ref), input));\n    }\n    o.level && (o.level = LEVEL_PAREN);\n    code = [input.compile(o)];\n    out = Block(output).compile((o.ref = new String(ref), o));\n    if (prog1 === 'cascade' && !o.ref.erred) {\n      this.carp(\"unreferred cascadee\");\n    }\n    if (!level) {\n      return sn.apply(null, [null].concat(slice$.call(code), [input.terminator, \"\\n\", out]));\n    }\n    code.push(\", \", out);\n    if (level > LEVEL_PAREN) {\n      return sn.apply(null, [null, \"(\"].concat(slice$.call(code), [\")\"]));\n    } else {\n      return sn.apply(null, [null].concat(slice$.call(code)));\n    }\n  };\n  return Cascade;\n}(Node));\nexports.JS = JS = (function(superclass){\n  var prototype = extend$((import$(JS, superclass).displayName = 'JS', JS), superclass).prototype, constructor = JS;\n  function JS(code, literal, comment){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.code = code;\n    this$.literal = literal;\n    this$.comment = comment;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  JS.prototype.show = function(){\n    if (this.comment) {\n      return this.code;\n    } else {\n      return \"`\" + this.code + \"`\";\n    }\n  };\n  JS.prototype.terminator = '';\n  prototype.isAssignable = prototype.isCallable = function(){\n    return !this.comment;\n  };\n  JS.prototype.compile = function(it){\n    return sn(this, snSafe(this.literal\n      ? entab(this.code, it.indent)\n      : this.code));\n  };\n  return JS;\n}(Node));\nexports.Require = Require = (function(superclass){\n  var prototype = extend$((import$(Require, superclass).displayName = 'Require', Require), superclass).prototype, constructor = Require;\n  function Require(body){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.body = body;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Require.prototype.children = ['body'];\n  Require.prototype.compile = function(o){\n    var getValue, processItem, code, i$, ref$, len$, item, this$ = this;\n    getValue = function(item, throwError){\n      switch (false) {\n      case !(item instanceof Key):\n        return item.name;\n      case !(item instanceof Var):\n        return item.value;\n      case !(item instanceof Literal):\n        return item.value;\n      default:\n        if (throwError) {\n          return this$.carp('invalid require! argument');\n        } else {\n          return item;\n        }\n      }\n    };\n    processItem = function(item){\n      var ref$, asg, value, asgValue, toAsg, main;\n      ref$ = (function(){\n        switch (false) {\n        case !(item instanceof Prop):\n          return [item.val, item.key];\n        default:\n          return [item, item];\n        }\n      }()), asg = ref$[0], value = ref$[1];\n      asgValue = getValue(asg);\n      toAsg = toString$.call(asgValue).slice(8, -1) === 'String' ? CopyL(asg, Var(nameFromPath(asgValue))) : asg;\n      value = stripString(getValue(value, true));\n      main = Chain(CopyL(this, Var('require'))).add(Call([Literal(\"'\" + value + \"'\")]));\n      return sn(item, Assign(toAsg, main).compile(o));\n    };\n    if (this.body.items != null) {\n      code = [];\n      for (i$ = 0, len$ = (ref$ = this.body.items).length; i$ < len$; ++i$) {\n        item = ref$[i$];\n        code.push(processItem(item), \";\\n\" + o.indent);\n      }\n      code.pop();\n      return sn.apply(null, [null].concat(slice$.call(code)));\n    } else {\n      return sn(null, processItem(this.body));\n    }\n  };\n  return Require;\n}(Node));\nexports.Util = Util = (function(superclass){\n  var prototype = extend$((import$(Util, superclass).displayName = 'Util', Util), superclass).prototype, constructor = Util;\n  function Util(verb){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.verb = verb;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Util.prototype.show = Jump.prototype.show;\n  Util.prototype.isCallable = YES;\n  Util.prototype.compile = function(){\n    return sn(this, util(this.verb));\n  };\n  Util.Extends = function(){\n    return Call.make(Util('extend'), [arguments[0], arguments[1]]);\n  };\n  return Util;\n}(Node));\nexports.Vars = Vars = (function(superclass){\n  var prototype = extend$((import$(Vars, superclass).displayName = 'Vars', Vars), superclass).prototype, constructor = Vars;\n  function Vars(vars){\n    var this$ = this instanceof ctor$ ? this : new ctor$;\n    this$.vars = vars;\n    return this$;\n  } function ctor$(){} ctor$.prototype = prototype;\n  Vars.prototype.children = ['vars'];\n  Vars.prototype.makeReturn = THIS;\n  Vars.prototype.compile = function(o, level){\n    var i$, ref$, len$, v, value;\n    for (i$ = 0, len$ = (ref$ = this.vars).length; i$ < len$; ++i$) {\n      v = ref$[i$], value = v.value;\n      if (!(v instanceof Var)) {\n        v.carp('invalid variable declaration');\n      }\n      if (o.scope.check(value)) {\n        v.carp(\"redeclaration of \\\"\" + value + \"\\\"\");\n      }\n      o.scope.declare(value, v);\n    }\n    return sn(this, Literal('void').compile(o, level));\n  };\n  return Vars;\n}(Node));\nexports.L = function(a, b, node){\n  if (node && typeof node === \"object\") {\n    node.first_line = a.first_line + 1;\n    node.first_column = a.first_column;\n    node.last_line = b.last_line + 1;\n    node.last_column = b.last_column;\n    node.line = a.first_line + 1;\n    node.column = a.first_column;\n  }\n  return node;\n};\nexports.CopyL = CopyL = function(a, node){\n  if (node && typeof node === \"object\") {\n    node.first_line = a.first_line;\n    node.first_column = a.first_column;\n    node.last_line = a.last_line;\n    node.last_column = a.last_column;\n    node.line = a.line;\n    node.column = a.column;\n  }\n  return node;\n};\nexports.Box = function(v){\n  if (typeof v === \"object\") {\n    return v;\n  } else {\n    return new v.constructor(v);\n  }\n};\nexports.Decl = function(type, nodes, lno){\n  if (!nodes[0]) {\n    throw SyntaxError(\"empty \" + type + \" on line \" + lno);\n  }\n  return DECLS[type](nodes);\n};\nDECLS = {\n  'export': function(lines){\n    var i, out, node, that, ref$;\n    i = -1;\n    out = Util('out');\n    while (node = lines[++i]) {\n      if (node instanceof Block) {\n        lines.splice.apply(lines, [i--, 1].concat(slice$.call(node.lines)));\n        continue;\n      }\n      if (that = node instanceof Fun && node.name) {\n        lines.splice(i++, 0, Assign(Chain(out, [Index(Key(that))]), Var(that)));\n        continue;\n      }\n      lines[i] = (that = node.varName() || node instanceof Assign && node.left.varName() || node instanceof Class && ((ref$ = node.title) != null ? ref$.varName() : void 8))\n        ? Assign(Chain(out, [Index(Key(that))]), node)\n        : Import(out, node);\n    }\n    return Block(lines);\n  },\n  'import': function(lines, all){\n    var i$, len$, i, line;\n    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {\n      i = i$;\n      line = lines[i$];\n      lines[i] = Import(Literal('this'), line, all);\n    }\n    return Block(lines);\n  },\n  importAll: function(it){\n    return this['import'](it, true);\n  },\n  'const': function(lines){\n    var i$, len$, node;\n    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {\n      node = lines[i$];\n      node.op === '=' || node.carp('invalid constant variable declaration');\n      node['const'] = true;\n    }\n    return Block(lines);\n  },\n  'var': Vars\n};\nfunction Scope(parent, shared){\n  this.parent = parent;\n  this.shared = shared;\n  this.variables = {};\n}\nref$ = Scope.prototype;\nref$.READ_ONLY = {\n  'const': 'constant',\n  'function': 'function',\n  undefined: 'undeclared'\n};\nref$.add = function(name, type, node){\n  var t, that;\n  if (node && (t = this.variables[name + \".\"])) {\n    if (that = this.READ_ONLY[t] || this.READ_ONLY[type]) {\n      node.carp(\"redeclaration of \" + that + \" \\\"\" + name + \"\\\"\");\n    } else if (t === type && type === 'arg') {\n      node.carp(\"duplicate parameter \\\"\" + name + \"\\\"\");\n    } else if (t === 'upvar') {\n      node.carp(\"accidental shadow of \\\"\" + name + \"\\\"\");\n    }\n    if (t === 'arg' || t === 'function') {\n      return name;\n    }\n  }\n  this.variables[name + \".\"] = type;\n  return name;\n};\nref$.get = function(name){\n  return this.variables[name + \".\"];\n};\nref$.declare = function(name, node, constant){\n  var that, scope;\n  if (that = this.shared) {\n    if (this.check(name)) {\n      return;\n    }\n    scope = that;\n  } else {\n    scope = this;\n  }\n  return scope.add(name, constant ? 'const' : 'var', node);\n};\nref$.assign = function(name, value){\n  return this.add(name, {\n    value: value\n  });\n};\nref$.temporary = function(name){\n  var ref$;\n  name || (name = 'ref');\n  while ((ref$ = this.variables[name + \"$.\"]) !== 'reuse' && ref$ !== void 8) {\n    name = name.length < 2 && name < 'z'\n      ? String.fromCharCode(name.charCodeAt() + 1)\n      : name.replace(/\\d*$/, fn$);\n  }\n  return this.add(name + '$', 'var');\n  function fn$(it){\n    return ++it;\n  }\n};\nref$.free = function(name){\n  return this.add(name, 'reuse');\n};\nref$.check = function(name, above){\n  var type, ref$;\n  if ((type = this.variables[name + \".\"]) || !above) {\n    return type;\n  }\n  return (ref$ = this.parent) != null ? ref$.check(name, above) : void 8;\n};\nref$.checkReadOnly = function(name){\n  var that, ref$, key$;\n  if (that = this.READ_ONLY[this.check(name, true)]) {\n    return that;\n  }\n  (ref$ = this.variables)[key$ = name + \".\"] || (ref$[key$] = 'upvar');\n  return '';\n};\nref$.emit = function(code, tab){\n  var vrs, asn, fun, name, ref$, type, that, val, declCode;\n  vrs = [];\n  asn = [];\n  fun = [];\n  for (name in ref$ = this.variables) {\n    type = ref$[name];\n    name = name.slice(0, -1);\n    if (type === 'var' || type === 'const' || type === 'reuse') {\n      vrs.push(name, \", \");\n    } else if (that = type.value) {\n      if (~(val = entab(that, tab)).toString().lastIndexOf('function(', 0)) {\n        if (val instanceof SourceNode) {\n          snRemoveLeft(val, 8);\n        } else {\n          val = val.slice(8);\n        }\n        fun.push(\"function \", name, val, \"\\n\" + tab);\n      } else {\n        asn.push(name, \" = \", val, \", \");\n      }\n    }\n  }\n  declCode = vrs.concat(asn);\n  declCode.pop();\n  fun.pop();\n  if (declCode.length > 0) {\n    code = sn.apply(null, [this, tab + \"var \"].concat(slice$.call(declCode), [\";\\n\", code]));\n  }\n  if (fun.length > 0) {\n    return sn.apply(null, [this, code, \"\\n\" + tab].concat(slice$.call(fun)));\n  } else {\n    return sn(this, code);\n  }\n};\nfunction YES(){\n  return true;\n}\nfunction NO(){\n  return false;\n}\nfunction THIS(){\n  return this;\n}\nfunction VOID(){}\nUTILS = {\n  clone: 'function(it){\\n  function fun(){} fun.prototype = it;\\n  return new fun;\\n}',\n  extend: 'function(sub, sup){\\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\\n  (sub.prototype = new fun).constructor = sub;\\n  if (typeof sup.extended == \\'function\\') sup.extended(sub);\\n  return sub;\\n}',\n  bind: 'function(obj, key, target){\\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\\n}',\n  'import': 'function(obj, src){\\n  var own = {}.hasOwnProperty;\\n  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\\n  return obj;\\n}',\n  importAll: 'function(obj, src){\\n  for (var key in src) obj[key] = src[key];\\n  return obj;\\n}',\n  repeatString: 'function(str, n){\\n  for (var r = \\'\\'; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;\\n  return r;\\n}',\n  repeatArray: 'function(arr, n){\\n  for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))\\n    if (n & 1) r.push.apply(r, arr);\\n  return r;\\n}',\n  'in': 'function(x, xs){\\n  var i = -1, l = xs.length >>> 0;\\n  while (++i < l) if (x === xs[i]) return true;\\n  return false;\\n}',\n  out: 'typeof exports != \\'undefined\\' && exports || this',\n  curry: 'function(f, bound){\\n  var context,\\n  _curry = function(args) {\\n    return f.length > 1 ? function(){\\n      var params = args ? args.concat() : [];\\n      context = bound ? context || this : this;\\n      return params.push.apply(params, arguments) <\\n          f.length && arguments.length ?\\n        _curry.call(context, params) : f.apply(context, params);\\n    } : f;\\n  };\\n  return _curry();\\n}',\n  flip: 'function(f){\\n  return curry$(function (x, y) { return f(y, x); });\\n}',\n  partialize: 'function(f, args, where){\\n  var context = this;\\n  return function(){\\n    var params = slice$.call(arguments), i,\\n        len = params.length, wlen = where.length,\\n        ta = args ? args.concat() : [], tw = where ? where.concat() : [];\\n    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }\\n    return len < wlen && len ?\\n      partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);\\n  };\\n}',\n  not: 'function(x){ return !x; }',\n  compose: 'function() {\\n  var functions = arguments;\\n  return function() {\\n    var i, result;\\n    result = functions[0].apply(this, arguments);\\n    for (i = 1; i < functions.length; ++i) {\\n      result = functions[i](result);\\n    }\\n    return result;\\n  };\\n}',\n  deepEq: 'function(x, y, type){\\n  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,\\n      has = function (obj, key) { return hasOwnProperty.call(obj, key); };\\n  var first = true;\\n  return eq(x, y, []);\\n  function eq(a, b, stack) {\\n    var className, length, size, result, alength, blength, r, key, ref, sizeB;\\n    if (a == null || b == null) { return a === b; }\\n    if (a.__placeholder__ || b.__placeholder__) { return true; }\\n    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\\n    className = toString.call(a);\\n    if (toString.call(b) != className) { return false; }\\n    switch (className) {\\n      case \\'[object String]\\': return a == String(b);\\n      case \\'[object Number]\\':\\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\\n      case \\'[object Date]\\':\\n      case \\'[object Boolean]\\':\\n        return +a == +b;\\n      case \\'[object RegExp]\\':\\n        return a.source == b.source &&\\n               a.global == b.global &&\\n               a.multiline == b.multiline &&\\n               a.ignoreCase == b.ignoreCase;\\n    }\\n    if (typeof a != \\'object\\' || typeof b != \\'object\\') { return false; }\\n    length = stack.length;\\n    while (length--) { if (stack[length] == a) { return true; } }\\n    stack.push(a);\\n    size = 0;\\n    result = true;\\n    if (className == \\'[object Array]\\') {\\n      alength = a.length;\\n      blength = b.length;\\n      if (first) {\\n        switch (type) {\\n        case \\'===\\': result = alength === blength; break;\\n        case \\'<==\\': result = alength <= blength; break;\\n        case \\'<<=\\': result = alength < blength; break;\\n        }\\n        size = alength;\\n        first = false;\\n      } else {\\n        result = alength === blength;\\n        size = alength;\\n      }\\n      if (result) {\\n        while (size--) {\\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }\\n        }\\n      }\\n    } else {\\n      if (\\'constructor\\' in a != \\'constructor\\' in b || a.constructor != b.constructor) {\\n        return false;\\n      }\\n      for (key in a) {\\n        if (has(a, key)) {\\n          size++;\\n          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }\\n        }\\n      }\\n      if (result) {\\n        sizeB = 0;\\n        for (key in b) {\\n          if (has(b, key)) { ++sizeB; }\\n        }\\n        if (first) {\\n          if (type === \\'<<=\\') {\\n            result = size < sizeB;\\n          } else if (type === \\'<==\\') {\\n            result = size <= sizeB\\n          } else {\\n            result = size === sizeB;\\n          }\\n        } else {\\n          first = false;\\n          result = size === sizeB;\\n        }\\n      }\\n    }\\n    stack.pop();\\n    return result;\\n  }\\n}',\n  split: \"''.split\",\n  replace: \"''.replace\",\n  toString: '{}.toString',\n  join: '[].join',\n  slice: '[].slice',\n  splice: '[].splice'\n};\nLEVEL_TOP = 0;\nLEVEL_PAREN = 1;\nLEVEL_LIST = 2;\nLEVEL_COND = 3;\nLEVEL_OP = 4;\nLEVEL_CALL = 5;\n(function(){\n  this['&&'] = this['||'] = this['xor'] = 0.2;\n  this['.&.'] = this['.^.'] = this['.|.'] = 0.3;\n  this['=='] = this['!='] = this['~='] = this['!~='] = this['==='] = this['!=='] = 0.4;\n  this['<'] = this['>'] = this['<='] = this['>='] = this.of = this['instanceof'] = 0.5;\n  this['<<='] = this['>>='] = this['<=='] = this['>=='] = this['++'] = 0.5;\n  this['.<<.'] = this['.>>.'] = this['.>>>.'] = 0.6;\n  this['+'] = this['-'] = 0.7;\n  this['*'] = this['/'] = this['%'] = 0.8;\n}.call(PREC = {\n  unary: 0.9\n}));\nTAB = '  ';\nID = /^(?!\\d)[\\w$\\xAA-\\uFFDC]+$/;\nSIMPLENUM = /^\\d+$/;\nfunction util(it){\n  return Scope.root.assign(it + '$', UTILS[it]);\n}\nfunction entab(code, tab){\n  return code.replace(/\\n/g, '\\n' + tab);\n}\nfunction import$(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n  return obj;\n}\nfunction clone$(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}\nfunction extend$(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == 'function') sup.extended(sub);\n  return sub;\n}\nfunction in$(x, xs){\n  var i = -1, l = xs.length >>> 0;\n  while (++i < l) if (x === xs[i]) return true;\n  return false;\n}\nfunction repeatArray$(arr, n){\n  for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))\n    if (n & 1) r.push.apply(r, arr);\n  return r;\n}\nfunction repeatString$(str, n){\n  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;\n  return r;\n}\nfunction importAll$(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}","/home/travis/build/npmtest/node-npmtest-livescript/node_modules/livescript/lib/util.js":"// Generated by LiveScript 1.5.0\nvar path, stripString, nameFromPath;\npath = require('path');\nstripString = function(val){\n  var that;\n  if (that = /^['\"](.*)['\"]$/.exec(val.trim())) {\n    return that[1];\n  } else {\n    return val;\n  }\n};\nnameFromPath = function(modulePath){\n  return path.basename(stripString(modulePath)).split('.')[0].replace(/-[a-z]/ig, function(it){\n    return it.charAt(1).toUpperCase();\n  });\n};\nmodule.exports = {\n  nameFromPath: nameFromPath,\n  stripString: stripString\n};","/home/travis/build/npmtest/node-npmtest-livescript/node_modules/livescript/lib/node.js":"// Generated by LiveScript 1.5.0\nmodule.exports = function(LiveScript){\n  var fs, path, events;\n  fs = require('fs');\n  path = require('path');\n  events = require('events');\n  LiveScript.run = function(code, options, arg$){\n    var filename, ref$, js, context, main, dirname, e;\n    if (options != null) {\n      filename = options.filename;\n    }\n    ref$ = arg$ != null\n      ? arg$\n      : {}, js = ref$.js, context = ref$.context;\n    main = require.main;\n    if (filename) {\n      dirname = path.dirname(fs.realpathSync(filename = process.argv[1] = path.resolve(filename)));\n    } else {\n      dirname = filename = '.';\n    }\n    main.paths = main.constructor._nodeModulePaths(dirname);\n    main.filename = filename;\n    if (!js) {\n      code = LiveScript.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$));\n    }\n    if (context) {\n      global.__runContext = context;\n      code = \"return (function() {\\n\" + code + \"\\n}).call(global.__runContext);\";\n    }\n    try {\n      return main._compile(code, filename);\n    } catch (e$) {\n      e = e$;\n      throw hackTrace(e, code, filename);\n    }\n  };\n  importAll$(LiveScript, events.EventEmitter.prototype);\n  require.extensions['.ls'] = function(module, filename){\n    var file, js, e;\n    file = fs.readFileSync(filename, 'utf8');\n    js = '.json.ls' === filename.substr(-8)\n      ? 'module.exports = ' + LiveScript.compile(file, {\n        filename: filename,\n        json: true\n      })\n      : LiveScript.compile(file, {\n        filename: filename,\n        bare: true,\n        map: \"embedded\"\n      }).code;\n    try {\n      return module._compile(js, filename);\n    } catch (e$) {\n      e = e$;\n      throw hackTrace(e, js, filename);\n    }\n  };\n};\nfunction hackTrace(error, js, filename){\n  var stack, traces, i$, len$, i, trace, index, lno, end, length, lines, j$, ref$, n;\n  if (error != null) {\n    stack = error.stack;\n  }\n  if (!stack) {\n    return error;\n  }\n  traces = stack.split('\\n');\n  if (!(traces.length > 1)) {\n    return error;\n  }\n  for (i$ = 0, len$ = traces.length; i$ < len$; ++i$) {\n    i = i$;\n    trace = traces[i$];\n    if (0 > (index = trace.indexOf(\"(\" + filename + \":\"))) {\n      continue;\n    }\n    lno = (/:(\\d+):/.exec(trace.slice(index + filename.length)) || '')[1];\n    if (!(lno = +lno)) {\n      continue;\n    }\n    end = lno + 4;\n    length = ('' + end).length;\n    lines || (lines = js.split('\\n'));\n    for (j$ = 1 > (ref$ = lno - 4) ? 1 : ref$; j$ <= end; ++j$) {\n      n = j$;\n      traces[i] += \"\\n\" + ('    ' + n).slice(-length) + \"\" + '|+'.charAt(n === lno) + \" \" + [lines[n - 1]];\n    }\n  }\n  return error.stack = traces.join('\\n'), error;\n}\nfunction import$(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n  return obj;\n}\nfunction importAll$(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}"}